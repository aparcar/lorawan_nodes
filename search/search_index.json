{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Start This project evaluates the LoRa frequency modulation and the LoRaWAN stack as an alternative for existing sensor setups using the technologies ZigBee and GSM . The current scope is to build a simple stack to gather sensor data end visualize them inside a web interface. Within this work modular nodes were designed allowing to measure a variety of environmental metrics, including temperature, rain fall, humidity and sea level. Both software and hardware of nodes is documented as well as a low cost monitoring setup as well as migration script to be compatible with existing setups. All work happened in collaboration with the MESH LAB at Oahu, Hawaii, supervised by Dr. Brian Glazer and Dr. Edo Biagioni . Sections Please follow the menu entries on the left to find more information on the topics. Software: Documentation on created software or setup examples. Hardware: Used hardware within this project including microcontrollers, gateways, PCB designs and outdoor casings. Resources: Description of used technologies, datasheets and used sensors.","title":"Start"},{"location":"#start","text":"This project evaluates the LoRa frequency modulation and the LoRaWAN stack as an alternative for existing sensor setups using the technologies ZigBee and GSM . The current scope is to build a simple stack to gather sensor data end visualize them inside a web interface. Within this work modular nodes were designed allowing to measure a variety of environmental metrics, including temperature, rain fall, humidity and sea level. Both software and hardware of nodes is documented as well as a low cost monitoring setup as well as migration script to be compatible with existing setups. All work happened in collaboration with the MESH LAB at Oahu, Hawaii, supervised by Dr. Brian Glazer and Dr. Edo Biagioni .","title":"Start"},{"location":"#sections","text":"Please follow the menu entries on the left to find more information on the topics. Software: Documentation on created software or setup examples. Hardware: Used hardware within this project including microcontrollers, gateways, PCB designs and outdoor casings. Resources: Description of used technologies, datasheets and used sensors.","title":"Sections"},{"location":"hardware/","text":"Overview This sections covers the used hardware within this project, which covers microcontrollers running software described in the Software section, used sensors as well as LoRaWAN gateways. Additional documentation is provided on the custom designed Printed circuit board (PCB) as well as the used outdoor casing. Microcontroller Gateways Printed Circuit Board","title":"Overview"},{"location":"hardware/#overview","text":"This sections covers the used hardware within this project, which covers microcontrollers running software described in the Software section, used sensors as well as LoRaWAN gateways. Additional documentation is provided on the custom designed Printed circuit board (PCB) as well as the used outdoor casing. Microcontroller Gateways Printed Circuit Board","title":"Overview"},{"location":"hardware/gateways/","text":"Gateways While the Microcontrollers with an attached LoRaWAN radio frequency module mostly send data, the receiving part is called gateway. Essentially it is a device with a LoRaWAN compatible receiver attached as well as an Internet connection. Received packages are forwarded to a brooker. More details on that are available in the LoRaWAN section Within this project the following three gateways were used as described below. This was partly necessary as LoRaWAN coverage with TheThingsNetwork broker were limited within the area of research, Honolulu, Ohau, Hawaii. At other locations institutions or private entities may already provide coverage free of charge. Using the TTNMapper it's possible to see a local coverage map and determine if a self maintained gateway is required. The Things Indoor Gateways This gateway allows simple operation since it's developed by the same people as the used LoRaWAN broker. It was used during local development and allows quick migration between different locations. While not waterproof, using additional casing and attaching an external antenna it can also be used as a outdoor gateway. A complete install and maintenance guide is available in the vendors documentation and is not replicated here. Heltec HT-M00 Just as the microcontrollers Heltec offers a development gateway as well . At the time of writing this is the cheapest development gateway available. The upstream documentation guides through the installation process of the gateway into TheThingsNetwork broker. Mikrotik wAP LR9 kit Lastly the outdoor LoRaWAN gateway from the vendor Mikrotik (in 900MHz or 860MHz ) offers the, at the time of writing, cheapest outdoor gateway. With Power over Ethernet (PoE) the installation is possible with a single Ethernet cable without requiring (ideally elevated) deployment location.","title":"Gateways"},{"location":"hardware/gateways/#gateways","text":"While the Microcontrollers with an attached LoRaWAN radio frequency module mostly send data, the receiving part is called gateway. Essentially it is a device with a LoRaWAN compatible receiver attached as well as an Internet connection. Received packages are forwarded to a brooker. More details on that are available in the LoRaWAN section Within this project the following three gateways were used as described below. This was partly necessary as LoRaWAN coverage with TheThingsNetwork broker were limited within the area of research, Honolulu, Ohau, Hawaii. At other locations institutions or private entities may already provide coverage free of charge. Using the TTNMapper it's possible to see a local coverage map and determine if a self maintained gateway is required.","title":"Gateways"},{"location":"hardware/gateways/#the-things-indoor-gateways","text":"This gateway allows simple operation since it's developed by the same people as the used LoRaWAN broker. It was used during local development and allows quick migration between different locations. While not waterproof, using additional casing and attaching an external antenna it can also be used as a outdoor gateway. A complete install and maintenance guide is available in the vendors documentation and is not replicated here.","title":"The Things Indoor Gateways"},{"location":"hardware/gateways/#heltec-ht-m00","text":"Just as the microcontrollers Heltec offers a development gateway as well . At the time of writing this is the cheapest development gateway available. The upstream documentation guides through the installation process of the gateway into TheThingsNetwork broker.","title":"Heltec HT-M00"},{"location":"hardware/gateways/#mikrotik-wap-lr9-kit","text":"Lastly the outdoor LoRaWAN gateway from the vendor Mikrotik (in 900MHz or 860MHz ) offers the, at the time of writing, cheapest outdoor gateway. With Power over Ethernet (PoE) the installation is possible with a single Ethernet cable without requiring (ideally elevated) deployment location.","title":"Mikrotik wAP LR9 kit"},{"location":"hardware/microcontroller/","text":"Microcontroller This section describes the used microcontrollers and development boards used within this setup. The microcontrollers is essentially an extremely small computer with hardware inputs and outputs. In simple terms, sensors are attached to the inputs and a LoRaWAN radio frequency module is connected to the outputs. Using microcontrollers comes in two flavors, either as development boards with populated connectors, for instance a USB port and attached LEDs or as a plain module, which requires designing of a custom PCB. The former is used for rapid prototyping while the latter runs on an optimized PCB which only contains required functionality. To simplify the development only microcontrollers compatible with the Arduino framework 1 were considered. The framework abstracts talking to low level hardware components and offers a simple C API to control the microcontrollers behaviour. Additionally this allows to migrate code from one device to another with minimal code modifications sine both devices understand the same API. Due to low price and using the LoRaWAN reference implementation the CubeCell product line from the vendor Heltec Automation 2 . Both development boards CubeCell Dev-Board ( htcc-ab01 ) and CubeCell Dev-Board Plus ( htcc-ab02 ) as well as the plain Module Plus ( htcc-am02 ) were used. Heltec CubeCell Dev-Board (Plus) The development boards shown on the right both allow to connect sensors via GPIO Pins as well as I2C 3 or serial console. Only the bigger Plus versions (bottom) contains two Analog to Digital converter (ADC) which are required for some sensor like the VH400 moisture sensor. Additionally the Plus version comes with an attached LCD display which can be used for debugging or additional information during setup. No long time tests were performed to evaluate the UV resistance of the display. For outdoor setups they come with a solar charge controller and battery connector which allows the usage without a constant power supply. Both boards use the same microcontroller and can run the same code. Flashing is trivial by using the USB connection and the Platformio framework . Dev-Board Pinout Dev-Board Plus Pinout Heltect CubeCell Module Plus The Module Plus allows (and requires) to use custom PCB and therefore only runs parts that are required. For production deployments the nodes would not need a LCD screen for debugging or a USB port for flashing. These components can simply be removed in the PCB design which reduces the number or parts, thereby cost and complexity. Dev-Board Plus and Module Plus use the same microcontroller and therefore support the same connections. More information on the PCB required for the Module Plus is available in the PCB section. Module Plus Pinout https://www.arduino.cc/ \u21a9 https://heltec.org/proudct_center/lora/cubecell/ \u21a9 https://www.arduino.cc/en/reference/wire \u21a9","title":"Microcontroller"},{"location":"hardware/microcontroller/#microcontroller","text":"This section describes the used microcontrollers and development boards used within this setup. The microcontrollers is essentially an extremely small computer with hardware inputs and outputs. In simple terms, sensors are attached to the inputs and a LoRaWAN radio frequency module is connected to the outputs. Using microcontrollers comes in two flavors, either as development boards with populated connectors, for instance a USB port and attached LEDs or as a plain module, which requires designing of a custom PCB. The former is used for rapid prototyping while the latter runs on an optimized PCB which only contains required functionality. To simplify the development only microcontrollers compatible with the Arduino framework 1 were considered. The framework abstracts talking to low level hardware components and offers a simple C API to control the microcontrollers behaviour. Additionally this allows to migrate code from one device to another with minimal code modifications sine both devices understand the same API. Due to low price and using the LoRaWAN reference implementation the CubeCell product line from the vendor Heltec Automation 2 . Both development boards CubeCell Dev-Board ( htcc-ab01 ) and CubeCell Dev-Board Plus ( htcc-ab02 ) as well as the plain Module Plus ( htcc-am02 ) were used.","title":"Microcontroller"},{"location":"hardware/microcontroller/#heltec-cubecell-dev-board-plus","text":"The development boards shown on the right both allow to connect sensors via GPIO Pins as well as I2C 3 or serial console. Only the bigger Plus versions (bottom) contains two Analog to Digital converter (ADC) which are required for some sensor like the VH400 moisture sensor. Additionally the Plus version comes with an attached LCD display which can be used for debugging or additional information during setup. No long time tests were performed to evaluate the UV resistance of the display. For outdoor setups they come with a solar charge controller and battery connector which allows the usage without a constant power supply. Both boards use the same microcontroller and can run the same code. Flashing is trivial by using the USB connection and the Platformio framework . Dev-Board Pinout Dev-Board Plus Pinout","title":"Heltec CubeCell Dev-Board (Plus)"},{"location":"hardware/microcontroller/#heltect-cubecell-module-plus","text":"The Module Plus allows (and requires) to use custom PCB and therefore only runs parts that are required. For production deployments the nodes would not need a LCD screen for debugging or a USB port for flashing. These components can simply be removed in the PCB design which reduces the number or parts, thereby cost and complexity. Dev-Board Plus and Module Plus use the same microcontroller and therefore support the same connections. More information on the PCB required for the Module Plus is available in the PCB section. Module Plus Pinout https://www.arduino.cc/ \u21a9 https://heltec.org/proudct_center/lora/cubecell/ \u21a9 https://www.arduino.cc/en/reference/wire \u21a9","title":"Heltect CubeCell Module Plus"},{"location":"hardware/pcb/","text":"Printed Circuit Board This section briefly describes the PCBs designed within this project. While breadboards are often used for prototyping with microcontroller, real deployments should use custom PCBs since they offer a more reliable setup. The project scope required a rain gauge sensor as well as a temperature sensor to transmit measurements over LoRaWAN to a online database. With the below described PCB it is possible to attach a Heltec HTCC-AB02 as well as the two sensors within minutes. Rain Box PCB As mentioned above the two values temperature and rain fall were to be collected and send to an online database. First prototypes using a breadboard and a Heltec HTCC-AB02 worked out as expected, so the same exact circuit was transfered in a PCB. On the right side a picture of the PCB is shown. The labels RAIN_GAUGE , SOLAR_IN and ONE_WIRE_IN contain screw terminals which allow easy attaching of the sensor cables. An EasyEda project file is available here for customization or ordering online. Additionally the BOM , Gerber and Pick & Place files are available: BOM_PCB_rain-box_htcc-ab02.csv Gerber_PCB_rain-box_htcc-ab02.zip PickAndPlace_PCB_rain-box_htcc-ab02.csv The PCB has a custom cutting so it fits perfectly into the outdoor case PTK-18420-C by Bud Industries, Inc. . It is important to order the C version since a clear cover is required to allow solar charging. Using cable glands it's possible to connect external sensors. The picture below shows two possible positions for 7mm holes to attach PG7 cable glands. Silicon was added around the cable glands for better long term water resistance. The full box specifications are available on the vendors website or as an attached resource . It is possible to use the Pick and Place file to order all parts soldered on or solder all components manually. In that case a 4.7K resistor should be added on the bottom left instead of a flat resistor. A picture of an assembled Rain Box is shown below. The picture shows four different setups of the rain gauges. The left box has a HOBO RG3 rain gauge The middle box has only a [DS18B20 temperature sensor] is connected inside the box. This was done to measure the maximum daily temperature inside the box. The right box has both a temperature sensor and a MISOL rain guage attached. By the time of writing (2021-09-16) the official vendor website is unreachable. In front is a PCB board without a box showing a connected Heltec HTCC-AB02 . PCB Editor To design PCBs a variety of tools is available for free. However the number of tools that are available on the three main platforms Windows, MacOSX and Linux is limited. Within this project EasyEda[^easyeda] was used for it's simple usage and integration with part libraries, which would simplify the ordering process. EasyEda comes with a tight integration of the PCB vendor JLCPCB which offers both creation of PCBs and also soldering of selected components. An extensive official documentation is available in English on the vendors website include video tutorials . If EasyEda is not an option the open source tools LibrePCB or KiCad could be used instead, however they are not covered here.","title":"Printed Circuit Board"},{"location":"hardware/pcb/#printed-circuit-board","text":"This section briefly describes the PCBs designed within this project. While breadboards are often used for prototyping with microcontroller, real deployments should use custom PCBs since they offer a more reliable setup. The project scope required a rain gauge sensor as well as a temperature sensor to transmit measurements over LoRaWAN to a online database. With the below described PCB it is possible to attach a Heltec HTCC-AB02 as well as the two sensors within minutes.","title":"Printed Circuit Board"},{"location":"hardware/pcb/#rain-box-pcb","text":"As mentioned above the two values temperature and rain fall were to be collected and send to an online database. First prototypes using a breadboard and a Heltec HTCC-AB02 worked out as expected, so the same exact circuit was transfered in a PCB. On the right side a picture of the PCB is shown. The labels RAIN_GAUGE , SOLAR_IN and ONE_WIRE_IN contain screw terminals which allow easy attaching of the sensor cables. An EasyEda project file is available here for customization or ordering online. Additionally the BOM , Gerber and Pick & Place files are available: BOM_PCB_rain-box_htcc-ab02.csv Gerber_PCB_rain-box_htcc-ab02.zip PickAndPlace_PCB_rain-box_htcc-ab02.csv The PCB has a custom cutting so it fits perfectly into the outdoor case PTK-18420-C by Bud Industries, Inc. . It is important to order the C version since a clear cover is required to allow solar charging. Using cable glands it's possible to connect external sensors. The picture below shows two possible positions for 7mm holes to attach PG7 cable glands. Silicon was added around the cable glands for better long term water resistance. The full box specifications are available on the vendors website or as an attached resource . It is possible to use the Pick and Place file to order all parts soldered on or solder all components manually. In that case a 4.7K resistor should be added on the bottom left instead of a flat resistor. A picture of an assembled Rain Box is shown below. The picture shows four different setups of the rain gauges. The left box has a HOBO RG3 rain gauge The middle box has only a [DS18B20 temperature sensor] is connected inside the box. This was done to measure the maximum daily temperature inside the box. The right box has both a temperature sensor and a MISOL rain guage attached. By the time of writing (2021-09-16) the official vendor website is unreachable. In front is a PCB board without a box showing a connected Heltec HTCC-AB02 .","title":"Rain Box PCB"},{"location":"hardware/pcb/#pcb-editor","text":"To design PCBs a variety of tools is available for free. However the number of tools that are available on the three main platforms Windows, MacOSX and Linux is limited. Within this project EasyEda[^easyeda] was used for it's simple usage and integration with part libraries, which would simplify the ordering process. EasyEda comes with a tight integration of the PCB vendor JLCPCB which offers both creation of PCBs and also soldering of selected components. An extensive official documentation is available in English on the vendors website include video tutorials . If EasyEda is not an option the open source tools LibrePCB or KiCad could be used instead, however they are not covered here.","title":"PCB Editor"},{"location":"resources/cayennelpp/","text":"CayenneLPP This section explain CayenneLPP (Low Power Protocol) which is used to encode data on sensor nodes into a size efficient format and decode it in the backend back for further processing. Cayenne is a platform developed by myDevices Inc. offering custom dashboards for device monitoring, alerts and more 1 . They developed CayenneLPP 2 and multiple open source implementation of that protocol exists 3 5 . The protocol allows a compromise between self describing data packets and size efficiency, which will be explained in the next section. This sections below show three ways to encode node data to a binary format for sending over LoRa, a custom raw format, JSON and CayenneLPP. The example data is a temperature value of 18.6 degree Celsius, a battery voltage of 3.9V and a distance value of 43mm. Encoding using raw Bits The smaller a LoRaWAN packet is the less power is required to send it and the more airtime is available for other sensors. A simple solution would be just store all sensor data as binary fields one after another. The packet could have the following format: 1 <temperature><voltage><distance> Representing floats in binary isn't trivial to instead a prevision can be defined. For temperature two float digits are enough, for battery voltage a single float digit is fine and dinstance is always a integer. This means values can be multiple by 100 respectively 10 . The temperature value becomes 1860 and the voltage becomes 39 . Both considering that measured temperature will never be above 99.99 degree Celsius and batter voltage should exceed 9.9V (4.2V really). For distance a maximum of 5000mm should be used. To calculate the maximum bits needed data, the maximum values are converted to binary format the bit counted, easily possible with some Python: 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> format ( 9999 , \"b\" ) # max value '10011100001111' >>> len ( format ( 9999 , \"b\" )) 14 >>> format ( 99 , \"b\" ) # max value '1100011' >>> len ( format ( 99 , \"b\" )) 7 >>> format ( 5000 , \"b\" ) # max value '1001110001000' >>> len ( format ( 5000 , \"b\" )) 13 >>> Above calculation shows that 14 Bits are needed for temperature, 7 for battery voltage and 13 for distance. Now the custom data format becomes more specific as shown below: 1 2 | temperature 14 | volt 7 | distance 13 | | xxxxxxxxxxxxxx | xxxxxxx | xxxxxxxxxxxxx | Below we calculate the specific values and pad them with zeros. 1 2 3 4 5 6 >>> format ( 1860 , \"b\" ) '11101000100' >>> format ( 39 , \"b\" ) '100111' >>> format ( 43 , \"b\" ) '101011' The resulting packet would look like this with a total size of 34 Bits . 1 2 | temperature 14 | volt 7 | distance 13 | | 00011101000100 | 0101011 | 0000000101011 | The receiving backend could decode this data by reading the first 14 Bits as integer and dividing the value by 100 to calculate the temperature, followed by reading Bit 15 until 21 as integer and dividing it by 10 to calculate the battery voltage. The remaining 13 Bit can be directly read as distance. While this approach works and data is efficiently exchanged between sensor node and backend, the calculation is not trivial to understand. More problematic is the extendability of this approach: Newly added sensors may use a different set of sensors and therefore require data fields. As the exchanged data is just Bits, it's not possible to know what the data contains. In other words, the format is extremely static and ideally the data would be more self explaining so a backend would know what value it is decoding. Encoding using JSON The JSON format is extremely popular in web application to exchange all kinds of data. It is human readable, supports all our data types directly (float and integer) and allows to verbosely describe data fields. The example data could be decoded as below: 1 2 3 4 5 { \"temperature_1\" : 18.6 , \"voltage_1\" : 3.9 , \"distance_1\" : 43 } As printed above, the format would take a total of 73 Bytes (584 Bits) which is nearly 20 times bigger than using the raw format. Even a slightly optimized version as shown below would still require 28 Bytes (224 Bits) meaning 7 times bigger. 1 { \"t1\" : 18.6 , \"v1\" : 3.9 , \"d1\" : 43 } Encoding using CayenneLPP CayenneLPP uses a compromise of both approaches, the data is very compact while being self descriptive. To archive that common measurement types are available with a 1 Byte data type descriptor and a 1 Byte data type channel (or ID). Each data type, be it temperature, GPS or relative humidity is described by a number between 0 and 255, a official reference implementation is available in the Cayenne Docs . Since all data types are based on IPSO data types other implementations support additional values, like voltage, altitude and distance 4 . Adding those values on device is done by a creating a CayenneLPP frame and adding values. More details are available in main.cpp implementation , however below is an simplified example. 1 2 3 4 5 6 CayenneLPP lpp ( LORAWAN_APP_DATA_MAX_SIZE ); // create frame lpp . addVoltage ( 1 , getBatteryVoltage ()); // add voltage lpp . addDistance ( 1 , distance ); // add distance in mm lpp . addTemperature ( 1 , temperature ); // add temperature in Celsius appDataSize = lpp . getSize (); // calculate size memcpy ( appData , lpp . getBuffer (), appDataSize ); // copy Bytes to LoRaWAN packet The same is possible to do via Python using the pycayennelpp package 5 : 1 2 3 4 5 6 7 8 from cayennelpp import LppFrame frame = LppFrame () frame . add_temperature ( 0 , 18.6 ) frame . add_distance ( 1 , 43 ) frame . add_voltage ( 1 , 3.9 ) buffer = bytes ( frame ) print ( len ( buffer )) The result are 14 Bytes and thereby half the size of using JSON. For measurements which are not directly supported by the implementations, like number of satelites for GPS measurements, it is possible to use the commands addDigitalInput or addDigitalOutput (unsigned 32 Bit Integer) and addAnalogInput or addAnalogOutput (float with 3 decimals). Decoding in Backend The receiving backend allows to decode incoming data before offering it via MQTT. This is very useful so different applications listening to the MQTT stream can directly process the decoded payload rather than implementing that per client, allowing as well to upgrade the communication used for nodes without modifying clients. TheThingsNetwork offers to automatically decode CayenneLPP frames using the Payload Formatter menu entry. However, since TheThingsNetwork uses the reference implementation of MyDevices they don't support decoding some additional data types, like distance. If these measurements are used it is possible to use a custom JavaScript decoder as offered by ElectronicCats to be used directly in TheThingsNetwork. The decoder.min.js can be pasted into the text field of the Payload Formatter menu entry: The min decoder version is required as TheThingsNetwork limits the total size of decoding scripts and the formated version exceeds that limit. Used payload types Within this project the following payload types and IDs are used. JSON value description analog_in_1 rain mm/m analog_in_2 soil moisture digital_out_1 running software version (integer) temperature_1 temperature voltage_1 battery voltage distance_1 distance to sea level https://developers.mydevices.com/cayenne/features/ \u21a9 https://developers.mydevices.com/cayenne/docs/lora/#lora-cayenne-low-power-payload \u21a9 https://github.com/ElectronicCats/CayenneLPP/ \u21a9 https://github.com/ElectronicCats/CayenneLPP/blob/master/API.md#methods-add \u21a9 https://github.com/smlng/pycayennelpp \u21a9 \u21a9","title":"CayenneLPP"},{"location":"resources/cayennelpp/#cayennelpp","text":"This section explain CayenneLPP (Low Power Protocol) which is used to encode data on sensor nodes into a size efficient format and decode it in the backend back for further processing. Cayenne is a platform developed by myDevices Inc. offering custom dashboards for device monitoring, alerts and more 1 . They developed CayenneLPP 2 and multiple open source implementation of that protocol exists 3 5 . The protocol allows a compromise between self describing data packets and size efficiency, which will be explained in the next section. This sections below show three ways to encode node data to a binary format for sending over LoRa, a custom raw format, JSON and CayenneLPP. The example data is a temperature value of 18.6 degree Celsius, a battery voltage of 3.9V and a distance value of 43mm.","title":"CayenneLPP"},{"location":"resources/cayennelpp/#encoding-using-raw-bits","text":"The smaller a LoRaWAN packet is the less power is required to send it and the more airtime is available for other sensors. A simple solution would be just store all sensor data as binary fields one after another. The packet could have the following format: 1 <temperature><voltage><distance> Representing floats in binary isn't trivial to instead a prevision can be defined. For temperature two float digits are enough, for battery voltage a single float digit is fine and dinstance is always a integer. This means values can be multiple by 100 respectively 10 . The temperature value becomes 1860 and the voltage becomes 39 . Both considering that measured temperature will never be above 99.99 degree Celsius and batter voltage should exceed 9.9V (4.2V really). For distance a maximum of 5000mm should be used. To calculate the maximum bits needed data, the maximum values are converted to binary format the bit counted, easily possible with some Python: 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> format ( 9999 , \"b\" ) # max value '10011100001111' >>> len ( format ( 9999 , \"b\" )) 14 >>> format ( 99 , \"b\" ) # max value '1100011' >>> len ( format ( 99 , \"b\" )) 7 >>> format ( 5000 , \"b\" ) # max value '1001110001000' >>> len ( format ( 5000 , \"b\" )) 13 >>> Above calculation shows that 14 Bits are needed for temperature, 7 for battery voltage and 13 for distance. Now the custom data format becomes more specific as shown below: 1 2 | temperature 14 | volt 7 | distance 13 | | xxxxxxxxxxxxxx | xxxxxxx | xxxxxxxxxxxxx | Below we calculate the specific values and pad them with zeros. 1 2 3 4 5 6 >>> format ( 1860 , \"b\" ) '11101000100' >>> format ( 39 , \"b\" ) '100111' >>> format ( 43 , \"b\" ) '101011' The resulting packet would look like this with a total size of 34 Bits . 1 2 | temperature 14 | volt 7 | distance 13 | | 00011101000100 | 0101011 | 0000000101011 | The receiving backend could decode this data by reading the first 14 Bits as integer and dividing the value by 100 to calculate the temperature, followed by reading Bit 15 until 21 as integer and dividing it by 10 to calculate the battery voltage. The remaining 13 Bit can be directly read as distance. While this approach works and data is efficiently exchanged between sensor node and backend, the calculation is not trivial to understand. More problematic is the extendability of this approach: Newly added sensors may use a different set of sensors and therefore require data fields. As the exchanged data is just Bits, it's not possible to know what the data contains. In other words, the format is extremely static and ideally the data would be more self explaining so a backend would know what value it is decoding.","title":"Encoding using raw Bits"},{"location":"resources/cayennelpp/#encoding-using-json","text":"The JSON format is extremely popular in web application to exchange all kinds of data. It is human readable, supports all our data types directly (float and integer) and allows to verbosely describe data fields. The example data could be decoded as below: 1 2 3 4 5 { \"temperature_1\" : 18.6 , \"voltage_1\" : 3.9 , \"distance_1\" : 43 } As printed above, the format would take a total of 73 Bytes (584 Bits) which is nearly 20 times bigger than using the raw format. Even a slightly optimized version as shown below would still require 28 Bytes (224 Bits) meaning 7 times bigger. 1 { \"t1\" : 18.6 , \"v1\" : 3.9 , \"d1\" : 43 }","title":"Encoding using JSON"},{"location":"resources/cayennelpp/#encoding-using-cayennelpp","text":"CayenneLPP uses a compromise of both approaches, the data is very compact while being self descriptive. To archive that common measurement types are available with a 1 Byte data type descriptor and a 1 Byte data type channel (or ID). Each data type, be it temperature, GPS or relative humidity is described by a number between 0 and 255, a official reference implementation is available in the Cayenne Docs . Since all data types are based on IPSO data types other implementations support additional values, like voltage, altitude and distance 4 . Adding those values on device is done by a creating a CayenneLPP frame and adding values. More details are available in main.cpp implementation , however below is an simplified example. 1 2 3 4 5 6 CayenneLPP lpp ( LORAWAN_APP_DATA_MAX_SIZE ); // create frame lpp . addVoltage ( 1 , getBatteryVoltage ()); // add voltage lpp . addDistance ( 1 , distance ); // add distance in mm lpp . addTemperature ( 1 , temperature ); // add temperature in Celsius appDataSize = lpp . getSize (); // calculate size memcpy ( appData , lpp . getBuffer (), appDataSize ); // copy Bytes to LoRaWAN packet The same is possible to do via Python using the pycayennelpp package 5 : 1 2 3 4 5 6 7 8 from cayennelpp import LppFrame frame = LppFrame () frame . add_temperature ( 0 , 18.6 ) frame . add_distance ( 1 , 43 ) frame . add_voltage ( 1 , 3.9 ) buffer = bytes ( frame ) print ( len ( buffer )) The result are 14 Bytes and thereby half the size of using JSON. For measurements which are not directly supported by the implementations, like number of satelites for GPS measurements, it is possible to use the commands addDigitalInput or addDigitalOutput (unsigned 32 Bit Integer) and addAnalogInput or addAnalogOutput (float with 3 decimals).","title":"Encoding using CayenneLPP"},{"location":"resources/cayennelpp/#decoding-in-backend","text":"The receiving backend allows to decode incoming data before offering it via MQTT. This is very useful so different applications listening to the MQTT stream can directly process the decoded payload rather than implementing that per client, allowing as well to upgrade the communication used for nodes without modifying clients. TheThingsNetwork offers to automatically decode CayenneLPP frames using the Payload Formatter menu entry. However, since TheThingsNetwork uses the reference implementation of MyDevices they don't support decoding some additional data types, like distance. If these measurements are used it is possible to use a custom JavaScript decoder as offered by ElectronicCats to be used directly in TheThingsNetwork. The decoder.min.js can be pasted into the text field of the Payload Formatter menu entry: The min decoder version is required as TheThingsNetwork limits the total size of decoding scripts and the formated version exceeds that limit.","title":"Decoding in Backend"},{"location":"resources/cayennelpp/#used-payload-types","text":"Within this project the following payload types and IDs are used. JSON value description analog_in_1 rain mm/m analog_in_2 soil moisture digital_out_1 running software version (integer) temperature_1 temperature voltage_1 battery voltage distance_1 distance to sea level https://developers.mydevices.com/cayenne/features/ \u21a9 https://developers.mydevices.com/cayenne/docs/lora/#lora-cayenne-low-power-payload \u21a9 https://github.com/ElectronicCats/CayenneLPP/ \u21a9 https://github.com/ElectronicCats/CayenneLPP/blob/master/API.md#methods-add \u21a9 https://github.com/smlng/pycayennelpp \u21a9 \u21a9","title":"Used payload types"},{"location":"resources/datasheets/","text":"Datasheets LoRa RFM9X - The radio module, which contains the SX1272 chipset SX1276 Semtech Datasheet SX1262 Semtech Datasheet","title":"Datasheets"},{"location":"resources/datasheets/#datasheets","text":"","title":"Datasheets"},{"location":"resources/datasheets/#lora","text":"RFM9X - The radio module, which contains the SX1272 chipset","title":"LoRa"},{"location":"resources/datasheets/#sx1276","text":"Semtech Datasheet","title":"SX1276"},{"location":"resources/datasheets/#sx1262","text":"Semtech Datasheet","title":"SX1262"},{"location":"resources/sensors/","text":"Sensors This section describes briefly sensors used within this project. All of them are supported by the Arduino framework an can be connected in any variation to the described microcontrollers . Distance To measure the distance between a fixed point and sea level the ultrasonic MB7389 sensor from MaxBotix Inc. was used. It offers a distance range of 300mm to 5000mm ( 5m ). Measurements happen 6 times per second and are readable via an analog, pulse width or serial output. The easiest implementation is done by using Arduinos softwareserial and read the distance values as chars. A full data sheet is available on the vendors website . Rain fall For rain fall two different rain gauges are used. While one is the de-facto standard for scientific publications, the other allows measurements at a much lower price. Both are usable by using a simple tip counter via an GPIO interrupt and are simply connected to a GND PIN and whichever PIN was configured with the interrupt. ONSET HOBO RG-3 The HOBO Rain Gauge by Onset Computer Corporation offers a high quality metal casing and is described as the default rain gauge for scientific publications. With it's precision comes the price of around $400 which may exceed the budget for some use cases. One tip means 0.254mm or 0.1\" of rainfall. Misol WH-SP-RG An alternative to is the WH-SP-RG by Misol . At the time of writing (2021-09-21) the vendors website is not reachable, however other websites sell the rain gauge for around $20 . One tip means 0.3851mm of rainfall. Soil Moisture For soil moisture the VH400 by Vegetronix, Inc is supported. The sensor is connected to an ADC ( Analog Digital Converter ) PIN and the measured resistance describes the volumetric water content by using a piecewise curve provided by the vendor. The curve is implemented in the provided mini library . The sensor costs around $40 . Temperature For waterproof temperature measuring a DS18B20 sold by Adafruit Industries, LLC is used. Adafruit ships their own libraries so minimal integration needs to be coded. The sensor uses three wires which can be directly connected to the custom PCB . The sensor costs ardoung $10 on the Adafruit website.","title":"Sensors"},{"location":"resources/sensors/#sensors","text":"This section describes briefly sensors used within this project. All of them are supported by the Arduino framework an can be connected in any variation to the described microcontrollers .","title":"Sensors"},{"location":"resources/sensors/#distance","text":"To measure the distance between a fixed point and sea level the ultrasonic MB7389 sensor from MaxBotix Inc. was used. It offers a distance range of 300mm to 5000mm ( 5m ). Measurements happen 6 times per second and are readable via an analog, pulse width or serial output. The easiest implementation is done by using Arduinos softwareserial and read the distance values as chars. A full data sheet is available on the vendors website .","title":"Distance"},{"location":"resources/sensors/#rain-fall","text":"For rain fall two different rain gauges are used. While one is the de-facto standard for scientific publications, the other allows measurements at a much lower price. Both are usable by using a simple tip counter via an GPIO interrupt and are simply connected to a GND PIN and whichever PIN was configured with the interrupt.","title":"Rain fall"},{"location":"resources/sensors/#onset-hobo-rg-3","text":"The HOBO Rain Gauge by Onset Computer Corporation offers a high quality metal casing and is described as the default rain gauge for scientific publications. With it's precision comes the price of around $400 which may exceed the budget for some use cases. One tip means 0.254mm or 0.1\" of rainfall.","title":"ONSET HOBO RG-3"},{"location":"resources/sensors/#misol-wh-sp-rg","text":"An alternative to is the WH-SP-RG by Misol . At the time of writing (2021-09-21) the vendors website is not reachable, however other websites sell the rain gauge for around $20 . One tip means 0.3851mm of rainfall.","title":"Misol WH-SP-RG"},{"location":"resources/sensors/#soil-moisture","text":"For soil moisture the VH400 by Vegetronix, Inc is supported. The sensor is connected to an ADC ( Analog Digital Converter ) PIN and the measured resistance describes the volumetric water content by using a piecewise curve provided by the vendor. The curve is implemented in the provided mini library . The sensor costs around $40 .","title":"Soil Moisture"},{"location":"resources/sensors/#temperature","text":"For waterproof temperature measuring a DS18B20 sold by Adafruit Industries, LLC is used. Adafruit ships their own libraries so minimal integration needs to be coded. The sensor uses three wires which can be directly connected to the custom PCB . The sensor costs ardoung $10 on the Adafruit website.","title":"Temperature"},{"location":"software/","text":"Overview The Software section describes all code and tooling used and created within this project. Below is a list of sub-sections describing the full setup in detail and should be followed in that order. It is recommended to read the Hardware section first to have the required sensor nodes for measurements and RaspberryPi or virtual machine to store data. Understanding and setting up TheThingsNetwork and LoRaWAN Setting up Platformio development framework Setting up sensor nodes to collect measurements Setting up InfluxDB to store measurements Setting up Grafana to visualize measurements","title":"Overview"},{"location":"software/#overview","text":"The Software section describes all code and tooling used and created within this project. Below is a list of sub-sections describing the full setup in detail and should be followed in that order. It is recommended to read the Hardware section first to have the required sensor nodes for measurements and RaspberryPi or virtual machine to store data. Understanding and setting up TheThingsNetwork and LoRaWAN Setting up Platformio development framework Setting up sensor nodes to collect measurements Setting up InfluxDB to store measurements Setting up Grafana to visualize measurements","title":"Overview"},{"location":"software/grafana/","text":"Grafana Dashboard Presenting collected data is important to make them accessible and give an overview of events before starting in-depths analytics. While multiple approaches to visualize data exists, this section describes the setup of Grafana. The advantages of Grafana compared to other solutions is the fact that without any coding skills appealing graphs and gauges can be created, offering a live and interactive user interface. Within this setup the combination with the InfluxDB database is described, however it is possible to visualize other data sources via Grafana. Installation To allow a cheap and reproducible setup these steps are done on a RaspberryPi running Raspbian , which allows low cost data hosing without requiring any server setups. However it is equally possible to run this on a virtual machine or even a laptop for testing. The Raspbian ports of Grafana are outdated and therefore the official Grafana repository is used instead: 1 2 3 4 5 echo \"deb https://packages.grafana.com/oss/deb stable main\" | \\d ocs sudo tee -a /etc/apt/sources.list.d/grafana.list wget -q -O - https://packages.grafana.com/gpg.key | sudo apt-key add - sudo apt update sudo apt install -y grafana-rpi More details on the Grafana installation steps are available in the official documentation . Adding InfluxDB as data source This setup run both Grafana as well as InfluxDB on a single RaspberryPi. Therefore it's possible to access the data locally. Other setups may use remote database on distributed systems, where data is stored on different machines than visualized. InfluxDB runs per default on port 8086 and if running, is available on localhost . None of the extra options need to be activated since a local setup doesn't require extra authentication settings except the login credentials set in the InfluxDB database setup. Configure a graphs A generic manual to add graphs or panels is provided by the Grafana Project itself within their documentation . This example describes how to get the battery voltage of all available nodes. A running InfluxDB receives data via Telegraf , feeding a MQTT stream into the time series database. If using the same options as in the InfluxDB section, Grafana will present a mqtt_consumer table from which data can be selected. Since the CayenneLPP protocol is used to encode senor data for LoRaWAN transmission, all fields in the table follow a specific schema: 1 uplink_message_decoded_payload_<cayennelpp_type>_<cayennelpp_id> All metrics start with uplink_message_decoded_payload since that contains transmissions from the node. Other fields may contain IDs of used gateways or transmission quality ( uplink_message_rx_metadata_0_rssi ), however these are more relevant to monitor the nodes health . The field of our interest is voltage with the ID 1 , the field is therefore called as follows: 1 uplink_message_decoded_payload_voltage_1 Once the field is selected measurements should be grouped by the device IDs. Grouping by means that a graph is created per device instead of showing all data in a single graph. The tag for grouping is called end_device_ids_device_id . Lastly to improve readability it is possible to assign an alias to each graph. Instead of having the lengthy full description 1 of a measurement only the device identifier can be shown. To do so the special value $tag_end_device_ids_device_id is added to the alias field. Example Dashboard Below is a screenshot of a demo setup which includes two graphs of measured metrics (rain fall and temperature) and below an overview of the nodes over the last week. It is possible to interactively select smaller and bigger time frames and see precise values for specific times and dates. Aboves two graphs show rain events that happened at different location in Honolulu, Hawaii. It's possible to zoom into specific time ranges to see the total amount of rain for that day, hour or minute. The temperature graph below the rain fall shows a repeating pattern of temperature changes. Two special cases are handled in this graph showing where rain-box-1 shows the inner enclosing temperature and rain-box-6 is stationed in a cooled lab, therefore the constantly low temperature. Additional values can be measured to track the health of sensors, most importantly the battery voltages and connection quality ( RSSI ). The graph above shows how the battery voltage is dropping every night but recharged on sunrise. On the contrary, above graphs show that the node sonic-2 doesn't recharge via it's attached solar panel and therefore shuts off once the battery voltage is to low for further LoRa transmissions. The node need manual inspection and probably a solar panel replacement. The graph above shows shows the varying values of RSSI, which describes the connection quality. For LoRa values down to -120dB are fine for a stable connection, so the node rain-box-1 should have a stable connection. mqtt_consumer.uplink_message_decoded_payload_voltage_1 {end_device_ids_device_id: rain-box-6} \u21a9","title":"Grafana Dashboard"},{"location":"software/grafana/#grafana-dashboard","text":"Presenting collected data is important to make them accessible and give an overview of events before starting in-depths analytics. While multiple approaches to visualize data exists, this section describes the setup of Grafana. The advantages of Grafana compared to other solutions is the fact that without any coding skills appealing graphs and gauges can be created, offering a live and interactive user interface. Within this setup the combination with the InfluxDB database is described, however it is possible to visualize other data sources via Grafana.","title":"Grafana Dashboard"},{"location":"software/grafana/#installation","text":"To allow a cheap and reproducible setup these steps are done on a RaspberryPi running Raspbian , which allows low cost data hosing without requiring any server setups. However it is equally possible to run this on a virtual machine or even a laptop for testing. The Raspbian ports of Grafana are outdated and therefore the official Grafana repository is used instead: 1 2 3 4 5 echo \"deb https://packages.grafana.com/oss/deb stable main\" | \\d ocs sudo tee -a /etc/apt/sources.list.d/grafana.list wget -q -O - https://packages.grafana.com/gpg.key | sudo apt-key add - sudo apt update sudo apt install -y grafana-rpi More details on the Grafana installation steps are available in the official documentation .","title":"Installation"},{"location":"software/grafana/#adding-influxdb-as-data-source","text":"This setup run both Grafana as well as InfluxDB on a single RaspberryPi. Therefore it's possible to access the data locally. Other setups may use remote database on distributed systems, where data is stored on different machines than visualized. InfluxDB runs per default on port 8086 and if running, is available on localhost . None of the extra options need to be activated since a local setup doesn't require extra authentication settings except the login credentials set in the InfluxDB database setup.","title":"Adding InfluxDB as data source"},{"location":"software/grafana/#configure-a-graphs","text":"A generic manual to add graphs or panels is provided by the Grafana Project itself within their documentation . This example describes how to get the battery voltage of all available nodes. A running InfluxDB receives data via Telegraf , feeding a MQTT stream into the time series database. If using the same options as in the InfluxDB section, Grafana will present a mqtt_consumer table from which data can be selected. Since the CayenneLPP protocol is used to encode senor data for LoRaWAN transmission, all fields in the table follow a specific schema: 1 uplink_message_decoded_payload_<cayennelpp_type>_<cayennelpp_id> All metrics start with uplink_message_decoded_payload since that contains transmissions from the node. Other fields may contain IDs of used gateways or transmission quality ( uplink_message_rx_metadata_0_rssi ), however these are more relevant to monitor the nodes health . The field of our interest is voltage with the ID 1 , the field is therefore called as follows: 1 uplink_message_decoded_payload_voltage_1 Once the field is selected measurements should be grouped by the device IDs. Grouping by means that a graph is created per device instead of showing all data in a single graph. The tag for grouping is called end_device_ids_device_id . Lastly to improve readability it is possible to assign an alias to each graph. Instead of having the lengthy full description 1 of a measurement only the device identifier can be shown. To do so the special value $tag_end_device_ids_device_id is added to the alias field.","title":"Configure a graphs"},{"location":"software/grafana/#example-dashboard","text":"Below is a screenshot of a demo setup which includes two graphs of measured metrics (rain fall and temperature) and below an overview of the nodes over the last week. It is possible to interactively select smaller and bigger time frames and see precise values for specific times and dates. Aboves two graphs show rain events that happened at different location in Honolulu, Hawaii. It's possible to zoom into specific time ranges to see the total amount of rain for that day, hour or minute. The temperature graph below the rain fall shows a repeating pattern of temperature changes. Two special cases are handled in this graph showing where rain-box-1 shows the inner enclosing temperature and rain-box-6 is stationed in a cooled lab, therefore the constantly low temperature. Additional values can be measured to track the health of sensors, most importantly the battery voltages and connection quality ( RSSI ). The graph above shows how the battery voltage is dropping every night but recharged on sunrise. On the contrary, above graphs show that the node sonic-2 doesn't recharge via it's attached solar panel and therefore shuts off once the battery voltage is to low for further LoRa transmissions. The node need manual inspection and probably a solar panel replacement. The graph above shows shows the varying values of RSSI, which describes the connection quality. For LoRa values down to -120dB are fine for a stable connection, so the node rain-box-1 should have a stable connection. mqtt_consumer.uplink_message_decoded_payload_voltage_1 {end_device_ids_device_id: rain-box-6} \u21a9","title":"Example Dashboard"},{"location":"software/influxdb/","text":"InfluxDB Database This sections covers briefly the setup of InfluxDB, a time series database which allows storing and querying metrics. Just like all other tools used within this document it's open source and all code is available online . Using InfluxDB comes with the two advantages of offering integrations for both Grafana as well consuming MQTT events, which is the way the LoRaWAN brooker reports metrics. Installation of InfluxDB While InfluxDB 2.0 was released this year, this document describes the setup and usage of InfluxDB 1.8. All tooling should be compatible with both versions and a migration guide might be added later on. The upstream documentation explains the installation process for various setups, for the RaspberryPi setup the Ubuntu & Debian steps should be followed. Within this documentation both database and user are called telegraf , however other use cases may use other values. Installation of Telegraf Telegraf is used to consume MQTT events and store them inside InfluxDB. InfluxDB and Telegraf are both developed by InfluxData Inc. , so a similar installation process is offered. Again the official installation guide for Ubuntu & Debian should be used. Once installed a custom configuration is required to consume data from TheThingsNetwork and store them locally. All values in <...> should be changed accordingly to the actual setup. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # /etc/telegraf/telegraf.conf [global_tags] [agent] interval = \"10s\" round_interval = true metric_batch_size = 1000 metric_buffer_limit = 10000 collection_jitter = \"0s\" flush_interval = \"10s\" flush_jitter = \"0s\" precision = \"\" hostname = \"\" omit_hostname = false [[outputs.influxdb]] database = \"telegraf\" urls = [ \"http://localhost:8086\" ] username = \"<influxdb_username>\" password = \"<influxdb_password>\" [[inputs.mqtt_consumer]] servers = [ \"tcp://nam1.cloud.thethings.network:1883\" ] topics = [ \"#\" ] username = \"<thethingsnetwork_username>\" password = \"NNSXS.<thethingsnetwork_api_token>\" data_format = \"json\" tag_keys = [ \"end_device_ids_device_id\" ] Once both services are running one should proceed setting up Grafana to create a dashboard presenting collected metrics.","title":"InfluxDB Database"},{"location":"software/influxdb/#influxdb-database","text":"This sections covers briefly the setup of InfluxDB, a time series database which allows storing and querying metrics. Just like all other tools used within this document it's open source and all code is available online . Using InfluxDB comes with the two advantages of offering integrations for both Grafana as well consuming MQTT events, which is the way the LoRaWAN brooker reports metrics.","title":"InfluxDB Database"},{"location":"software/influxdb/#installation-of-influxdb","text":"While InfluxDB 2.0 was released this year, this document describes the setup and usage of InfluxDB 1.8. All tooling should be compatible with both versions and a migration guide might be added later on. The upstream documentation explains the installation process for various setups, for the RaspberryPi setup the Ubuntu & Debian steps should be followed. Within this documentation both database and user are called telegraf , however other use cases may use other values.","title":"Installation of InfluxDB"},{"location":"software/influxdb/#installation-of-telegraf","text":"Telegraf is used to consume MQTT events and store them inside InfluxDB. InfluxDB and Telegraf are both developed by InfluxData Inc. , so a similar installation process is offered. Again the official installation guide for Ubuntu & Debian should be used. Once installed a custom configuration is required to consume data from TheThingsNetwork and store them locally. All values in <...> should be changed accordingly to the actual setup. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # /etc/telegraf/telegraf.conf [global_tags] [agent] interval = \"10s\" round_interval = true metric_batch_size = 1000 metric_buffer_limit = 10000 collection_jitter = \"0s\" flush_interval = \"10s\" flush_jitter = \"0s\" precision = \"\" hostname = \"\" omit_hostname = false [[outputs.influxdb]] database = \"telegraf\" urls = [ \"http://localhost:8086\" ] username = \"<influxdb_username>\" password = \"<influxdb_password>\" [[inputs.mqtt_consumer]] servers = [ \"tcp://nam1.cloud.thethings.network:1883\" ] topics = [ \"#\" ] username = \"<thethingsnetwork_username>\" password = \"NNSXS.<thethingsnetwork_api_token>\" data_format = \"json\" tag_keys = [ \"end_device_ids_device_id\" ] Once both services are running one should proceed setting up Grafana to create a dashboard presenting collected metrics.","title":"Installation of Telegraf"},{"location":"software/platformio/","text":"Platformio This section describes the usage of the Platformio framework for embedded development. Similar to the Arduino IDE 1 it allows the management of dependencies and compilation for a wide variety of devices. Due to its simple installation and full support for the used hardware it was preferred over other the Arduino IDE , however other tooling should be possible as well. Installation A full installation guide is available in the upstream documentation however the basic installation boils down to a running Python 3 installation combined with the Python Packet Manager or curl : 1 2 3 4 5 pip install -U platformio # or python3 -c \" $( curl -fsSL https://raw.githubusercontent.com/platformio/platformio/master/scripts/get-platformio.py ) \" After the installation the shortcut pio executes the binary. Creating a project Adding projects is as easy as creating a folder and running pio to initialize the project in the current folder. 1 2 mkdir project/ && cd project/ pio project init After the initialization the following files are created: 1 2 3 4 5 include/ # header files lib/ # libraries platformio.ini # platformio configuration file src/ # source code (e.g. main.cpp) test/ # automatic tests See the Git repository folder node/ to see the main project structure. platformio.ini The configuration file contains one or multiple environments per used device type. Within this projects environments for the devices cube_cell_board , cubecell_board_plus and cubecell_module_plus are used. The file below defines multiple aspects or the project which simplify development: board_build.ardiono.* defines values passed during compile time to enable and configure specific features. upload_port defines the local connection, which allows to have multiple devices connected at once and test them in parallel lib_deps defines all required dependencies which can be hosted within the Platformio registry 2 or Git repositories directly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ; PlatformIO Project Configuration File ; ; Build options: build flags, source filter ; Upload options: custom upload port, speed and extra flags ; Library options: dependencies, extra library storages ; Advanced options: extra scripting ; ; Please visit documentation for the other options and examples ; https://docs.platformio.org/page/projectconf.html [env:cubecell_board_plus] board = cubecell_board_plus platform = asrmicro650x framework = arduino board_build.arduino.lorawan.region = US915 board_build.arduino.lorawan.netmode = OTAA board_build.arduino.lorawan.adr = ON monitor_speed = 115200 upload_port = /dev/ttyUSB0 lib_deps = https://github.com/ElectronicCats/CayenneLPP.git#master bblanchon/ArduinoJson @ ^6.17.2 practicalarduino/SHT1x@0.0.0-alpha+sha.be7042c3e3 [env:cubecell_board] board = cubecell_board platform = asrmicro650x framework = arduino board_build.arduino.lorawan.region = US915 board_build.arduino.lorawan.netmode = OTAA board_build.arduino.lorawan.adr = ON monitor_speed = 115200 upload_port = /dev/ttyUSB0 lib_deps = https://github.com/ElectronicCats/CayenneLPP.git bblanchon/ArduinoJson @ ^6.17.2 practicalarduino/SHT1x@0.0.0-alpha+sha.be7042c3e3 [env:cubecell_module_plus] board = cubecell_module_plus platform = asrmicro650x framework = arduino board_build.arduino.lorawan.region = US915 board_build.arduino.lorawan.netmode = OTAA board_build.arduino.lorawan.adr = ON monitor_speed = 115200 upload_port = /dev/ttyUSB0 lib_deps = https://github.com/ElectronicCats/CayenneLPP.git#master bblanchon/ArduinoJson @ ^6.17.2 practicalarduino/SHT1x@0.0.0-alpha+sha.be7042c3e3 Flashing nodes Once a sensor node is connected it's can be flashed using the following command: 1 pio run --target upload For convenience it is also possible to upload and monitor the serial output at once: 1 pio run --target upload --target monitor https://www.arduino.cc/en/software/ \u21a9 https://platformio.org/lib \u21a9","title":"Platformio"},{"location":"software/platformio/#platformio","text":"This section describes the usage of the Platformio framework for embedded development. Similar to the Arduino IDE 1 it allows the management of dependencies and compilation for a wide variety of devices. Due to its simple installation and full support for the used hardware it was preferred over other the Arduino IDE , however other tooling should be possible as well.","title":"Platformio"},{"location":"software/platformio/#installation","text":"A full installation guide is available in the upstream documentation however the basic installation boils down to a running Python 3 installation combined with the Python Packet Manager or curl : 1 2 3 4 5 pip install -U platformio # or python3 -c \" $( curl -fsSL https://raw.githubusercontent.com/platformio/platformio/master/scripts/get-platformio.py ) \" After the installation the shortcut pio executes the binary.","title":"Installation"},{"location":"software/platformio/#creating-a-project","text":"Adding projects is as easy as creating a folder and running pio to initialize the project in the current folder. 1 2 mkdir project/ && cd project/ pio project init After the initialization the following files are created: 1 2 3 4 5 include/ # header files lib/ # libraries platformio.ini # platformio configuration file src/ # source code (e.g. main.cpp) test/ # automatic tests See the Git repository folder node/ to see the main project structure.","title":"Creating a project"},{"location":"software/platformio/#platformioini","text":"The configuration file contains one or multiple environments per used device type. Within this projects environments for the devices cube_cell_board , cubecell_board_plus and cubecell_module_plus are used. The file below defines multiple aspects or the project which simplify development: board_build.ardiono.* defines values passed during compile time to enable and configure specific features. upload_port defines the local connection, which allows to have multiple devices connected at once and test them in parallel lib_deps defines all required dependencies which can be hosted within the Platformio registry 2 or Git repositories directly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ; PlatformIO Project Configuration File ; ; Build options: build flags, source filter ; Upload options: custom upload port, speed and extra flags ; Library options: dependencies, extra library storages ; Advanced options: extra scripting ; ; Please visit documentation for the other options and examples ; https://docs.platformio.org/page/projectconf.html [env:cubecell_board_plus] board = cubecell_board_plus platform = asrmicro650x framework = arduino board_build.arduino.lorawan.region = US915 board_build.arduino.lorawan.netmode = OTAA board_build.arduino.lorawan.adr = ON monitor_speed = 115200 upload_port = /dev/ttyUSB0 lib_deps = https://github.com/ElectronicCats/CayenneLPP.git#master bblanchon/ArduinoJson @ ^6.17.2 practicalarduino/SHT1x@0.0.0-alpha+sha.be7042c3e3 [env:cubecell_board] board = cubecell_board platform = asrmicro650x framework = arduino board_build.arduino.lorawan.region = US915 board_build.arduino.lorawan.netmode = OTAA board_build.arduino.lorawan.adr = ON monitor_speed = 115200 upload_port = /dev/ttyUSB0 lib_deps = https://github.com/ElectronicCats/CayenneLPP.git bblanchon/ArduinoJson @ ^6.17.2 practicalarduino/SHT1x@0.0.0-alpha+sha.be7042c3e3 [env:cubecell_module_plus] board = cubecell_module_plus platform = asrmicro650x framework = arduino board_build.arduino.lorawan.region = US915 board_build.arduino.lorawan.netmode = OTAA board_build.arduino.lorawan.adr = ON monitor_speed = 115200 upload_port = /dev/ttyUSB0 lib_deps = https://github.com/ElectronicCats/CayenneLPP.git#master bblanchon/ArduinoJson @ ^6.17.2 practicalarduino/SHT1x@0.0.0-alpha+sha.be7042c3e3","title":"platformio.ini"},{"location":"software/platformio/#flashing-nodes","text":"Once a sensor node is connected it's can be flashed using the following command: 1 pio run --target upload For convenience it is also possible to upload and monitor the serial output at once: 1 pio run --target upload --target monitor https://www.arduino.cc/en/software/ \u21a9 https://platformio.org/lib \u21a9","title":"Flashing nodes"},{"location":"software/thethingsnetwork/","text":"LoRaWAN This section gives a brief introduction to LoRaWAN and how it builds on top of the radio frequency modulation called LoRa . In short LoRaWAN offers a secure transport for data between sensor nodes collecting metrics and a user controlled backend. The illustration below shows the stack. Sensor Nodes collect data and send it via LoRa radio frequency modulation (red lines) to Gateways . A gateway has a LoRa compatible radio module and antenna attach and listens for incoming messages. Once received, messages are forwarded to a broker or Network Server . The network server, in this setups case thethingsnetwork.org, manages user accounts and applications . Each application has multiple Nodes assigned with individual login credentials. Forwarded messages from gateways are offered via MQTT to user of specified application. User controlled Application Servers can listen to MQTT streams and store sensor data for further processing. No user can access applications of other users and all traffic, starting from sensor nodes until the application server is encrypted. This allows a federation of infrastructure since multiple entities can share access to a single gateway without being able to manipulate each others data. As an outcome, both private hobbyists and institutions like universities can offer gateway access and thereby work together to cover large areas. Different projects don't have to manage their infrastructure independently but can share gateways. Since all traffic is encrypted and authenticated as defined by the LoRaWAN standard, no code has to be written by users to allow secure connections. Lastly multiple integrations allow even easier setups than described within this document. Instead of running a self managed database, it is also possible to rely on cloud services storing MQTT messages and offering convenient interfaces. TheThingsNetwork broker The cloud service requires a free online account and the setup of an Application . Each application then contains multiple End devices which which provide sensor data. Received data is offered via an MQTT API can should be consumed by a user controlled database, in this setup InfluxDB or one of the integrations. The above image shows currently active end devices, their identifiers as well as the time of the last received message. Aboves picture shows the MQTT login credentials which can be either used within the InfluxDB setup to have Telegraf listen to MQTT and store data or for other applications. Below is a short Python script called mqtt2json.py which listens to the MQTT stream and outputs lines of JSON which can be consumed by other applications. A generic script like this allows custom downstream handling of incoming sensor data. As proof of concept the script below is parsed by another tool adding measurements to a SQL database and visualize them via a custom web page grogdata . Nodes are identified via the from field and all payload is stored in the p field, containing data fields based on CayenneLPP . 1 Below is an example output of the script which could be read by future tooling using the JSON Lines standard 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 {\"from\": \"rain-box-5\", \"p\": {\"temperature_1\": 23.1}} {\"from\": \"rain-box-1\", \"p\": {\"temperature_1\": 23.5}} {\"from\": \"sonic-2\", \"p\": {\"distance_1\": 4.991}} {\"from\": \"rain-box-6\", \"p\": {\"temperature_1\": 21.4}} {\"from\": \"rain-box-4\", \"p\": {\"digital_out_1\": 2, \"voltage_1\": 4.15}} {\"from\": \"sonic-2\", \"p\": {\"distance_1\": 5}} {\"from\": \"rain-box-5\", \"p\": {\"digital_out_1\": 2, \"voltage_1\": 4.22}} {\"from\": \"sonic-2\", \"p\": {\"distance_1\": 5}} {\"from\": \"rain-box-4\", \"p\": {\"temperature_1\": 24.7}} {\"from\": \"rain-box-5\", \"p\": {\"temperature_1\": 23.6}} {\"from\": \"rain-box-1\", \"p\": {\"temperature_1\": 23.6}} {\"from\": \"sonic-2\", \"p\": {\"distance_1\": 5}} {\"from\": \"rain-box-6\", \"p\": {\"temperature_1\": 21.5}} {\"from\": \"rain-box-3\", \"p\": {\"temperature_1\": 24.1}} {\"from\": \"sonic-2\", \"p\": {\"distance_1\": 5}} {\"from\": \"sonic-2\", \"p\": {\"distance_1\": 5}} {\"from\": \"rain-box-4\", \"p\": {\"temperature_1\": 24.6}} {\"from\": \"rain-box-5\", \"p\": {\"temperature_1\": 23}} {\"from\": \"rain-box-1\", \"p\": {\"temperature_1\": 23.7}} ... https://jsonlines.org/ \u21a9","title":"LoRaWAN"},{"location":"software/thethingsnetwork/#lorawan","text":"This section gives a brief introduction to LoRaWAN and how it builds on top of the radio frequency modulation called LoRa . In short LoRaWAN offers a secure transport for data between sensor nodes collecting metrics and a user controlled backend. The illustration below shows the stack. Sensor Nodes collect data and send it via LoRa radio frequency modulation (red lines) to Gateways . A gateway has a LoRa compatible radio module and antenna attach and listens for incoming messages. Once received, messages are forwarded to a broker or Network Server . The network server, in this setups case thethingsnetwork.org, manages user accounts and applications . Each application has multiple Nodes assigned with individual login credentials. Forwarded messages from gateways are offered via MQTT to user of specified application. User controlled Application Servers can listen to MQTT streams and store sensor data for further processing. No user can access applications of other users and all traffic, starting from sensor nodes until the application server is encrypted. This allows a federation of infrastructure since multiple entities can share access to a single gateway without being able to manipulate each others data. As an outcome, both private hobbyists and institutions like universities can offer gateway access and thereby work together to cover large areas. Different projects don't have to manage their infrastructure independently but can share gateways. Since all traffic is encrypted and authenticated as defined by the LoRaWAN standard, no code has to be written by users to allow secure connections. Lastly multiple integrations allow even easier setups than described within this document. Instead of running a self managed database, it is also possible to rely on cloud services storing MQTT messages and offering convenient interfaces.","title":"LoRaWAN"},{"location":"software/thethingsnetwork/#thethingsnetwork-broker","text":"The cloud service requires a free online account and the setup of an Application . Each application then contains multiple End devices which which provide sensor data. Received data is offered via an MQTT API can should be consumed by a user controlled database, in this setup InfluxDB or one of the integrations. The above image shows currently active end devices, their identifiers as well as the time of the last received message. Aboves picture shows the MQTT login credentials which can be either used within the InfluxDB setup to have Telegraf listen to MQTT and store data or for other applications. Below is a short Python script called mqtt2json.py which listens to the MQTT stream and outputs lines of JSON which can be consumed by other applications. A generic script like this allows custom downstream handling of incoming sensor data. As proof of concept the script below is parsed by another tool adding measurements to a SQL database and visualize them via a custom web page grogdata . Nodes are identified via the from field and all payload is stored in the p field, containing data fields based on CayenneLPP . 1 Below is an example output of the script which could be read by future tooling using the JSON Lines standard 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 {\"from\": \"rain-box-5\", \"p\": {\"temperature_1\": 23.1}} {\"from\": \"rain-box-1\", \"p\": {\"temperature_1\": 23.5}} {\"from\": \"sonic-2\", \"p\": {\"distance_1\": 4.991}} {\"from\": \"rain-box-6\", \"p\": {\"temperature_1\": 21.4}} {\"from\": \"rain-box-4\", \"p\": {\"digital_out_1\": 2, \"voltage_1\": 4.15}} {\"from\": \"sonic-2\", \"p\": {\"distance_1\": 5}} {\"from\": \"rain-box-5\", \"p\": {\"digital_out_1\": 2, \"voltage_1\": 4.22}} {\"from\": \"sonic-2\", \"p\": {\"distance_1\": 5}} {\"from\": \"rain-box-4\", \"p\": {\"temperature_1\": 24.7}} {\"from\": \"rain-box-5\", \"p\": {\"temperature_1\": 23.6}} {\"from\": \"rain-box-1\", \"p\": {\"temperature_1\": 23.6}} {\"from\": \"sonic-2\", \"p\": {\"distance_1\": 5}} {\"from\": \"rain-box-6\", \"p\": {\"temperature_1\": 21.5}} {\"from\": \"rain-box-3\", \"p\": {\"temperature_1\": 24.1}} {\"from\": \"sonic-2\", \"p\": {\"distance_1\": 5}} {\"from\": \"sonic-2\", \"p\": {\"distance_1\": 5}} {\"from\": \"rain-box-4\", \"p\": {\"temperature_1\": 24.6}} {\"from\": \"rain-box-5\", \"p\": {\"temperature_1\": 23}} {\"from\": \"rain-box-1\", \"p\": {\"temperature_1\": 23.7}} ... https://jsonlines.org/ \u21a9","title":"TheThingsNetwork broker"},{"location":"software/node/","text":"Overview This section describes the software used on nodes. Within this overview page information on the usage of Platformio and provisioning via the provision.py script is given. On device code For further information on the C code see the following sections: config.h Contains node specific configuration options, like what sensors to enable on what PINs. This should be modified per use case, for instance when creating a new series of rain gauges measuring moisture as well, the sensor should be enabled here. Per node configuration happens via the provision.py script after flashing. main.cpp Contains the main loop which connects to sensors and sends LoRaWAN packets. VH400.cpp Minimal library to communicate with VH400 moisture sensor. MB7389.cpp Minimal library to communicate with MB7389 ultrasonic sensor.","title":"Overview"},{"location":"software/node/#overview","text":"This section describes the software used on nodes. Within this overview page information on the usage of Platformio and provisioning via the provision.py script is given.","title":"Overview"},{"location":"software/node/#on-device-code","text":"For further information on the C code see the following sections: config.h Contains node specific configuration options, like what sensors to enable on what PINs. This should be modified per use case, for instance when creating a new series of rain gauges measuring moisture as well, the sensor should be enabled here. Per node configuration happens via the provision.py script after flashing. main.cpp Contains the main loop which connects to sensors and sends LoRaWAN packets. VH400.cpp Minimal library to communicate with VH400 moisture sensor. MB7389.cpp Minimal library to communicate with MB7389 ultrasonic sensor.","title":"On device code"},{"location":"software/node/MB7389.cpp/","text":"MB7389.cpp This mini library reads serial distance measurements from a MB7389 ultrasonic distance sensor. Within this project it is used to measure sea level and tides, however it could be used for other purposes as well, for instance gasoline levels of tanks. The MB7389 sensor returns via serial connection 6 times a second the current distance. A returned string stars with the upper case letter R and ends with a carrier return \\r , between are four digits containing the distance, i.e. R4301 would describe a distance of 4301 millimeters or 4.301 meters. It is possible to provide the get_sonic_distance() function a counter value which return the average of N measurements, for instance 60 to get the average distance of a minute. The software serial only requires the RX PIN since no data is ever send to the distance sensor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include <softSerial.h> uint32_t get_sonic_distance ( softSerial softwareSerial , uint32_t count ) { boolean foundValue ; boolean foundStart ; String inString ; uint32_t measurements = 0 ; uint32_t total = 0 ; uint32_t start ; softwareSerial . begin ( 9600 ); while ( ! softwareSerial . available ()) { } // Run loop until enough measurements were read while ( measurements < count ) { // Since measurements may fail resulting in a retry after 1/6 seconds, store // the start time so one a measurement is successfully read, start the next // measurement exactly a second later. start = millis (); // Reset variables used to find measurement foundStart = false ; foundValue = false ; inString = \"\" ; // Flush software serial input softwareSerial . flush (); // Loop until a single measurement is found while ( ! foundValue ) { if ( softwareSerial . available ()) { char inChar = softwareSerial . read (); if ( foundStart == false ) { // New measurements begin with the character `R` if ( inChar == 'R' ) { foundStart = true ; } else { // If not, skip the letter and repeat softwareSerial . read (); } } else { // Measurements end with character `\\r`. If any other value is found // add it to our measurement. if ( inChar != '\\r' ) { inString += inChar ; } else { // If found character is `\\r` and therefore end of a measurement, // check if the length is actually four character. If not, repeat // the process. if ( inString . length () != 4 ) { Serial . println ( \"incomplete measurement\" ); foundStart = false ; inString = \"\" ; } else { // Found available measurement, increase counter and begin again foundValue = true ; total += inString . toInt (); measurements += 1 ; // Wait 1 second minus the time it took to read the last // measurement delay ( 1000 - ( millis () - start )); } } } } else { // Give the software serial more time to read characters delay ( 50 ); } } } // Return average of measurements and convert it to cm (sensor returns mm) return ( total / ( count * 10 )); // to cm }","title":"MB7389.cpp"},{"location":"software/node/MB7389.cpp/#mb7389cpp","text":"This mini library reads serial distance measurements from a MB7389 ultrasonic distance sensor. Within this project it is used to measure sea level and tides, however it could be used for other purposes as well, for instance gasoline levels of tanks. The MB7389 sensor returns via serial connection 6 times a second the current distance. A returned string stars with the upper case letter R and ends with a carrier return \\r , between are four digits containing the distance, i.e. R4301 would describe a distance of 4301 millimeters or 4.301 meters. It is possible to provide the get_sonic_distance() function a counter value which return the average of N measurements, for instance 60 to get the average distance of a minute. The software serial only requires the RX PIN since no data is ever send to the distance sensor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include <softSerial.h> uint32_t get_sonic_distance ( softSerial softwareSerial , uint32_t count ) { boolean foundValue ; boolean foundStart ; String inString ; uint32_t measurements = 0 ; uint32_t total = 0 ; uint32_t start ; softwareSerial . begin ( 9600 ); while ( ! softwareSerial . available ()) { } // Run loop until enough measurements were read while ( measurements < count ) { // Since measurements may fail resulting in a retry after 1/6 seconds, store // the start time so one a measurement is successfully read, start the next // measurement exactly a second later. start = millis (); // Reset variables used to find measurement foundStart = false ; foundValue = false ; inString = \"\" ; // Flush software serial input softwareSerial . flush (); // Loop until a single measurement is found while ( ! foundValue ) { if ( softwareSerial . available ()) { char inChar = softwareSerial . read (); if ( foundStart == false ) { // New measurements begin with the character `R` if ( inChar == 'R' ) { foundStart = true ; } else { // If not, skip the letter and repeat softwareSerial . read (); } } else { // Measurements end with character `\\r`. If any other value is found // add it to our measurement. if ( inChar != '\\r' ) { inString += inChar ; } else { // If found character is `\\r` and therefore end of a measurement, // check if the length is actually four character. If not, repeat // the process. if ( inString . length () != 4 ) { Serial . println ( \"incomplete measurement\" ); foundStart = false ; inString = \"\" ; } else { // Found available measurement, increase counter and begin again foundValue = true ; total += inString . toInt (); measurements += 1 ; // Wait 1 second minus the time it took to read the last // measurement delay ( 1000 - ( millis () - start )); } } } } else { // Give the software serial more time to read characters delay ( 50 ); } } } // Return average of measurements and convert it to cm (sensor returns mm) return ( total / ( count * 10 )); // to cm }","title":"MB7389.cpp"},{"location":"software/node/VH400.cpp/","text":"VH400.cpp This mini library read analog voltages via an ADC (Analog to Digital Converter) PIN and converts the value to VWC (Volumetric Water Content). The constants used are provided by the vendor . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \"Arduino.h\" float read_VH400 ( uint8_t VH400_PIN ) { float vh400_voltage = analogRead ( VH400_PIN ) * ( 3.0 / 4095.0 ); float VWC ; // Calculate VWC based on voltages provided by vendor: // https://vegetronix.com/Products/VH400/VH400-Piecewise-Curve.phtml if ( vh400_voltage <= 1.1 ) { VWC = 10 * vh400_voltage - 1 ; } else if ( vh400_voltage <= 1.3 ) { VWC = 25 * vh400_voltage - 17.5 ; } else if ( vh400_voltage <= 1.82 ) { VWC = 48.08 * vh400_voltage - 47.5 ; } else if ( vh400_voltage <= 2.2 ) { VWC = 26.32 * vh400_voltage - 7.89 ; } else if ( vh400_voltage <= 3.0 ) { VWC = 62.5 * vh400_voltage - 87.5 ; } else { VWC = 0.0 ; } return ( VWC ); }","title":"VH400.cpp"},{"location":"software/node/VH400.cpp/#vh400cpp","text":"This mini library read analog voltages via an ADC (Analog to Digital Converter) PIN and converts the value to VWC (Volumetric Water Content). The constants used are provided by the vendor . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \"Arduino.h\" float read_VH400 ( uint8_t VH400_PIN ) { float vh400_voltage = analogRead ( VH400_PIN ) * ( 3.0 / 4095.0 ); float VWC ; // Calculate VWC based on voltages provided by vendor: // https://vegetronix.com/Products/VH400/VH400-Piecewise-Curve.phtml if ( vh400_voltage <= 1.1 ) { VWC = 10 * vh400_voltage - 1 ; } else if ( vh400_voltage <= 1.3 ) { VWC = 25 * vh400_voltage - 17.5 ; } else if ( vh400_voltage <= 1.82 ) { VWC = 48.08 * vh400_voltage - 47.5 ; } else if ( vh400_voltage <= 2.2 ) { VWC = 26.32 * vh400_voltage - 7.89 ; } else if ( vh400_voltage <= 3.0 ) { VWC = 62.5 * vh400_voltage - 87.5 ; } else { VWC = 0.0 ; } return ( VWC ); }","title":"VH400.cpp"},{"location":"software/node/config.h/","text":"config.h This section describes All code described here is found in node/include/common.h . Below is a highlighted version of the code fragment 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 /* * Describes the currently running version. This value is transmitted next to * the battery voltage and helps to keep track what software version is running * on nodes. It should be increased whenever a significant change to logic * happens which may change the behaviour of a running device. */ #define VERSION 4 // How often to send battery voltage (and version) in minutes #define BATTERY_SEND_INTERVAL 360 // 6 hours // How often to send OneWire temperature in minutes #define ONEWIRE_SEND_INTERVAL 30 // How often to send MB7389 sonic distance in minutes #define SONIC_SEND_INTERVAL 10 // How often to send VH400 moisture in minutes #define VH400_SEND_INTERVAL 3 /* * Setting PINs to devices will enable them within the code. The default values * presented here work fine with Heltec CubeCell boards, allowing to attach all * sensor at once. However it is also possible to remove any PIN definition and * thereby disable the sensor completely. */ // #define ONEWIRE_PIN GPIO4 #define SONIC_RX_PIN GPIO1 // #define RAIN_GAUGE_PIN GPIO5 // #define VH400_PIN ADC2 // This defines the fallback value of mm/t if not provided by the node // configuration file. The default value corresponds to a HOBO RG3. #define DEFAULT_MM_PER_COUNT 0.254 // 0.01\" /* * All options below are advanced and specifically for the LoRaWAN library used. * None of these values should require manual changes except when using outside * the US915 zone or using ABP rather than OTAA. */ // OTAA parameters should be set via AT commands in the configuration file. uint8_t devEui [] = { 0xC0 , 0xFF , 0xEE , 0xC0 , 0xFF , 0xEE , 0xCA , 0xFE }; uint8_t appEui [] = { 0xC0 , 0xFF , 0xEE , 0xC0 , 0xFF , 0xEE , 0xCA , 0xFE }; uint8_t appKey [] = { 0xC0 , 0xFF , 0xEE , 0xC0 , 0xFF , 0xEE , 0xC0 , 0xFF , 0xEE , 0xC0 , 0xFF , 0xEE , 0xC0 , 0xFF , 0xEE , 0x42 }; /* * While it is possible to use ABP it is not recommended, please use OTAA! * OTAA is more secure and allows the node and backend to negotiate an ideal * transmission rate to safe power and air-time. */ uint8_t nwkSKey [] = {}; uint8_t appSKey [] = {}; uint32_t devAddr = ( uint32_t ) 0x0 ; /*LoraWan channelsmask, default channels 0-7 sub 2*/ uint16_t userChannelsMask [ 6 ] = { 0xFF00 , 0x0000 , 0x0000 , 0x0000 , 0x0000 , 0x0000 }; /*LoraWan region, select in arduino IDE tools*/ LoRaMacRegion_t loraWanRegion = ACTIVE_REGION ; /*LoraWan Class, Class A and Class C are supported*/ DeviceClass_t loraWanClass = LORAWAN_CLASS ; /*OTAA or ABP*/ bool overTheAirActivation = LORAWAN_NETMODE ; /*ADR enable*/ bool loraWanAdr = LORAWAN_ADR ; /* set LORAWAN_Net_Reserve ON, the node could save the network info to flash, * when node reset not need to join again */ // bool keepNet = LORAWAN_NET_RESERVE; bool keepNet = false ; /* Indicates if the node is sending confirmed or unconfirmed messages */ bool isTxConfirmed = false ; /*! * Number of trials to transmit the frame, if the LoRaMAC layer did not * receive an acknowledgment. The MAC performs a datarate adaptation, * according to the LoRaWAN Specification V1.0.2, chapter 18.4, according * to the following table: * * Transmission nb | Data Rate * ----------------|----------- * 1 (first) | DR * 2 | DR * 3 | max(DR-1,0) * 4 | max(DR-1,0) * 5 | max(DR-2,0) * 6 | max(DR-2,0) * 7 | max(DR-3,0) * 8 | max(DR-3,0) * * Note, that if NbTrials is set to 1 or 2, the MAC will not decrease * the datarate, in case the LoRaMAC layer did not receive an acknowledgment */ uint8_t confirmedNbTrials = 4 ;","title":"config.h"},{"location":"software/node/config.h/#configh","text":"This section describes All code described here is found in node/include/common.h . Below is a highlighted version of the code fragment 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 /* * Describes the currently running version. This value is transmitted next to * the battery voltage and helps to keep track what software version is running * on nodes. It should be increased whenever a significant change to logic * happens which may change the behaviour of a running device. */ #define VERSION 4 // How often to send battery voltage (and version) in minutes #define BATTERY_SEND_INTERVAL 360 // 6 hours // How often to send OneWire temperature in minutes #define ONEWIRE_SEND_INTERVAL 30 // How often to send MB7389 sonic distance in minutes #define SONIC_SEND_INTERVAL 10 // How often to send VH400 moisture in minutes #define VH400_SEND_INTERVAL 3 /* * Setting PINs to devices will enable them within the code. The default values * presented here work fine with Heltec CubeCell boards, allowing to attach all * sensor at once. However it is also possible to remove any PIN definition and * thereby disable the sensor completely. */ // #define ONEWIRE_PIN GPIO4 #define SONIC_RX_PIN GPIO1 // #define RAIN_GAUGE_PIN GPIO5 // #define VH400_PIN ADC2 // This defines the fallback value of mm/t if not provided by the node // configuration file. The default value corresponds to a HOBO RG3. #define DEFAULT_MM_PER_COUNT 0.254 // 0.01\" /* * All options below are advanced and specifically for the LoRaWAN library used. * None of these values should require manual changes except when using outside * the US915 zone or using ABP rather than OTAA. */ // OTAA parameters should be set via AT commands in the configuration file. uint8_t devEui [] = { 0xC0 , 0xFF , 0xEE , 0xC0 , 0xFF , 0xEE , 0xCA , 0xFE }; uint8_t appEui [] = { 0xC0 , 0xFF , 0xEE , 0xC0 , 0xFF , 0xEE , 0xCA , 0xFE }; uint8_t appKey [] = { 0xC0 , 0xFF , 0xEE , 0xC0 , 0xFF , 0xEE , 0xC0 , 0xFF , 0xEE , 0xC0 , 0xFF , 0xEE , 0xC0 , 0xFF , 0xEE , 0x42 }; /* * While it is possible to use ABP it is not recommended, please use OTAA! * OTAA is more secure and allows the node and backend to negotiate an ideal * transmission rate to safe power and air-time. */ uint8_t nwkSKey [] = {}; uint8_t appSKey [] = {}; uint32_t devAddr = ( uint32_t ) 0x0 ; /*LoraWan channelsmask, default channels 0-7 sub 2*/ uint16_t userChannelsMask [ 6 ] = { 0xFF00 , 0x0000 , 0x0000 , 0x0000 , 0x0000 , 0x0000 }; /*LoraWan region, select in arduino IDE tools*/ LoRaMacRegion_t loraWanRegion = ACTIVE_REGION ; /*LoraWan Class, Class A and Class C are supported*/ DeviceClass_t loraWanClass = LORAWAN_CLASS ; /*OTAA or ABP*/ bool overTheAirActivation = LORAWAN_NETMODE ; /*ADR enable*/ bool loraWanAdr = LORAWAN_ADR ; /* set LORAWAN_Net_Reserve ON, the node could save the network info to flash, * when node reset not need to join again */ // bool keepNet = LORAWAN_NET_RESERVE; bool keepNet = false ; /* Indicates if the node is sending confirmed or unconfirmed messages */ bool isTxConfirmed = false ; /*! * Number of trials to transmit the frame, if the LoRaMAC layer did not * receive an acknowledgment. The MAC performs a datarate adaptation, * according to the LoRaWAN Specification V1.0.2, chapter 18.4, according * to the following table: * * Transmission nb | Data Rate * ----------------|----------- * 1 (first) | DR * 2 | DR * 3 | max(DR-1,0) * 4 | max(DR-1,0) * 5 | max(DR-2,0) * 6 | max(DR-2,0) * 7 | max(DR-3,0) * 8 | max(DR-3,0) * * Note, that if NbTrials is set to 1 or 2, the MAC will not decrease * the datarate, in case the LoRaMAC layer did not receive an acknowledgment */ uint8_t confirmedNbTrials = 4 ;","title":"config.h"},{"location":"software/node/main.cpp/","text":"main.cpp This section describes the modular node which allows to collect and send environmental metrics to a backend. While it is possible to use pure LoRa to communicate with a backend, the code provided here uses only LoRaWAN . While a specific hardware was used to build the nodes, it is possible to replace the transmission logic with other libraries. All code described here is found in node/src/main.cpp . Below is a highlighted version of the code fragment 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 #include \"Arduino.h\" . #include \"LoRaWan_APP.h\" #include \"config.h\" #include <CayenneLPP.h> #include <DallasTemperature.h> #include <OneWire.h> #include <SPI.h> #include <Wire.h> #include <softSerial.h> #include \"MB7389.h\" #include \"VH400.h\" // This section allows to store data on the device. Specifically this allows to // store the rain gauge *mm per tip* value. #define ROW 0 #define ROW_OFFSET 100 // CY_FLASH_SIZEOF_ROW is 256 , CY_SFLASH_USERBASE is 0x0ffff400 #define addr_rain_gauge \\ CY_SFLASH_USERBASE + CY_FLASH_SIZEOF_ROW *ROW + ROW_OFFSET CayenneLPP lpp ( LORAWAN_APP_DATA_MAX_SIZE ); // Set to BATTERY_SEND_INTERVAL to send on start uint32_t battery_send_counter = BATTERY_SEND_INTERVAL ; // Run cycle every minute uint32_t appTxDutyCycle = 60000 ; // Send messages on specific port. For this application all data is transmitted // on port 2. The port is used to distinguish between packet types, however // since this implementation uses CayenneLPP which is parsed by the backend, all // data can be sent over the same port. uint8_t appPort = 2 ; // Initialize variables required for rain gauge use #ifdef RAIN_GAUGE_PIN // union to store directly on EEPROM union { float number ; uint8_t bytes [ 4 ]; } mm_per_tip ; // The tip counter and mm, must reset after each cycle static volatile uint8_t tips = 0 ; static unsigned long last_switch ; #endif // Initialize variables required for OneWire temperature // // The current setup only supports a single connected sensor while it is easily // possible to monitor multiple OneWire sensors at the same time. #ifdef ONEWIRE_PIN OneWire onewire ( ONEWIRE_PIN ); DallasTemperature onewire_sensor ( & onewire ); uint32_t onewire_send_counter = 0 ; float onewire_total = 0.0 ; #endif // Initialize variables required for VH400 moisture sensor #ifdef VH400_PIN uint32_t vh400_send_counter = 0 ; float vh400_total = 0.0 ; #endif // Initialize variables for MB7389 ultrasonic distance sensor #ifdef SONIC_RX_PIN uint32_t sonic_send_counter = 0 ; uint32_t sonic_total = 0 ; softSerial sonicSerial ( 0 , SONIC_RX_PIN ); #endif // Prepare the outgoing packet stored in CayenneLPP format // // The packet might be empty and sending is omitted for that cycle. static void prepareTxFrame () { lpp . reset (); // Send battery status only every \"BATTERY_SEND_INTERVAL\" minutes if ( battery_send_counter >= BATTERY_SEND_INTERVAL ) { Serial . printf ( \"[%i/%i] Add battery volt \\n \" , battery_send_counter , BATTERY_SEND_INTERVAL ); // Battery voltage is stored as voltage with ID 1 lpp . addVoltage ( 1 , getBatteryVoltage () / 1000.0 ); // Running version is stored as digital output with ID 1 lpp . addDigitalOutput ( 1 , VERSION ); // Reset counter battery_send_counter = 0 ; } else { Serial . printf ( \"[%i/%i] Skip battery volt \\n \" , battery_send_counter , BATTERY_SEND_INTERVAL ); battery_send_counter ++ ; } #ifdef SONIC_RX_PIN sonic_total += get_sonic_distance ( sonicSerial , 60 ); sonic_send_counter ++ ; if ( sonic_send_counter == SONIC_SEND_INTERVAL ) { Serial . printf ( \"[%i/%i] Add sonic \\n \" , sonic_send_counter , SONIC_SEND_INTERVAL ); // Sea level is stored as distance with ID 1 lpp . addDistance ( 1 , (( float ) sonic_total / sonic_send_counter ) / 100.0 ); // Reset counters sonic_send_counter = 0 ; sonic_total = 0 ; } else { Serial . printf ( \"[%i/%i] Skip sonic \\n \" , sonic_send_counter , SONIC_SEND_INTERVAL ); } #endif #ifdef RAIN_GAUGE_PIN if ( tips > 0 ) { Serial . printf ( \"Tips = %i \\n \" , tips ); // Rain fall is stored as analog with ID 1 // The CayenneLPP specification do not support rain fall directly lpp . addAnalogInput ( 1 , mm_per_tip . number * tips ); // Reset counter tips = 0 ; } else { Serial . printf ( \"Skip rain gauge \\n \" ); } #endif #ifdef VH400_PIN vh400_total += read_VH400 ( VH400_PIN ); vh400_send_counter ++ ; if ( vh400_send_counter >= VH400_SEND_INTERVAL ) { Serial . printf ( \"[%i/%i] Add VH400 \\n \" , vh400_send_counter , VH400_SEND_INTERVAL ); // Moisture is stored as analog with ID 2 // The CayenneLPP specification do not support moisture directly lpp . addAnalogInput ( 2 , vh400_total / vh400_send_counter ); // Reset counters vh400_send_counter = 0 ; vh400_total = 0.0 ; } else { Serial . printf ( \"[%i/%i] Skip VH400 \\n \" , vh400_send_counter , VH400_SEND_INTERVAL ); } #endif #ifdef ONEWIRE_PIN onewire_sensor . requestTemperatures (); onewire_total += onewire_sensor . getTempCByIndex ( 0 ); onewire_send_counter ++ ; if ( onewire_send_counter >= ONEWIRE_SEND_INTERVAL ) { Serial . printf ( \"[%i/%i] Add OneWire \\n \" , onewire_send_counter , ONEWIRE_SEND_INTERVAL ); // Temperature is stored as temperature with ID 1 lpp . addTemperature ( 1 , onewire_total / onewire_send_counter ); // Reset counters onewire_send_counter = 0 ; onewire_total = 0.0 ; } else { Serial . printf ( \"[%i/%i] Skip OneWire \\n \" , onewire_send_counter , ONEWIRE_SEND_INTERVAL ); } #endif // Copy CayenneLPP frame to appData, which will be send lpp . getBuffer (), appDataSize = lpp . getSize (); memcpy ( appData , lpp . getBuffer (), appDataSize ); } // Custom commands to provision device // // At this point only the rain gauge command `mmPerTip` is supported, however it // is easily possible to extend this to e.g. support height setting of the tide // gauges or other user specific commands. bool checkUserAt ( char * cmd , char * content ) { #ifdef RAIN_GAUGE_PIN // This command is used to set the tipping bucket size // - HOBO RG3: 0.254mm/t // - Misol WH-SP-RG: 0.3851mm/t if ( strcmp ( cmd , \"mmPerTip\" ) == 0 ) { if ( atof ( content ) != mm_per_tip . number ) { mm_per_tip . number = atof ( content ); Serial . print ( \"+OK Set mm per tip to \" ); Serial . print ( mm_per_tip . number , 4 ); Serial . println ( \"mm\" ); Serial . println (); FLASH_update ( addr_rain_gauge , mm_per_tip . bytes , sizeof ( mm_per_tip . bytes )); } else { Serial . println ( \"+OK Same mm per tip as before\" ); } return true ; } #endif return false ; } #ifdef RAIN_GAUGE_PIN // Run on each interrupt aka tip of the tipping bucket void interrupt_handler () { tips ++ ; delay ( 250 ); } #endif // The Arduino setup() function run on every boot void setup () { // Set baudrate to 115200 Serial . begin ( 115200 ); Serial . println ( \"So it begins...\" ); #ifdef RAIN_GAUGE_PIN // Read mm/t from EEPROM Serial . println ( \"Enable rain gauge sensor\" ); FLASH_read_at ( addr_rain_gauge , mm_per_tip . bytes , sizeof ( mm_per_tip . bytes )); if ( mm_per_tip . number == 0.0 ) { mm_per_tip . number = DEFAULT_MM_PER_COUNT ; } Serial . printf ( \"Current mm per tip is \" ); Serial . print ( mm_per_tip . number , 4 ); Serial . println ( \"mm\" ); // Enable interrupt pin for tips PINMODE_INPUT_PULLUP ( RAIN_GAUGE_PIN ); attachInterrupt ( RAIN_GAUGE_PIN , interrupt_handler , FALLING ); #endif #ifdef ONEWIRE_PIN // Setup OneWire and print single test measurement Serial . println ( \"Enable OneWire sensor\" ); onewire_sensor . begin (); onewire_sensor . requestTemperatures (); Serial . print ( \"temperature = \" ); Serial . print ( onewire_sensor . getTempCByIndex ( 0 ), 2 ); Serial . println (); #endif // Enable user input via Serial for AT commands enableAt (); #ifdef VH400_PIN // Setup VH400 sensor and print single test measurement Serial . println ( \"Enable VH400 sensor\" ); pinMode ( VH400_PIN , INPUT ); Serial . print ( \"moisture = \" ); Serial . print ( readVH400 ( VH400_PIN ), 2 ) Serial . println (); #endif #ifdef SONIC_RX_PIN // Print single test measurement Serial . println ( \"Enable sonic sensor\" ); Serial . print ( \"distance = \" ); Serial . print ( get_sonic_distance ( sonicSerial , 1 )); Serial . println (); #endif // Set Arduino into the initialization state deviceState = DEVICE_STATE_INIT ; LoRaWAN . ifskipjoin (); } void loop () { switch ( deviceState ) { case DEVICE_STATE_INIT : { getDevParam (); printDevParam (); LoRaWAN . init ( loraWanClass , loraWanRegion ); deviceState = DEVICE_STATE_JOIN ; break ; } case DEVICE_STATE_JOIN : { LoRaWAN . join (); break ; } case DEVICE_STATE_SEND : { prepareTxFrame (); // Do not send empty packages if ( appDataSize > 0 ) { LoRaWAN . send (); } else { Serial . println ( \"Package is empty, don't send anything\" ); } deviceState = DEVICE_STATE_CYCLE ; break ; } case DEVICE_STATE_CYCLE : { // If sonic sensor is enabled it will measure 60 times a minute and return the // average. This way waves don't influence tide estimations as much. Since a // measurement is required every second the duty cycle is skipped and instead // the get_sonic_distance function runs, which blocks for 60 seconds. // If no sonic sensor is attached, use the #ifdef SONIC_RX_PIN LoRaWAN . sleep (); // Add random delay so sensors don't repetitively send at the same time. // This is done do avoid a situation where many sensors start at the same // time and collectively overload the gateway every 60 seconds. delay ( randr ( 0 , APP_TX_DUTYCYCLE_RND )); deviceState = DEVICE_STATE_SEND ; #else // Same random delay is applied here. txDutyCycleTime = appTxDutyCycle + randr ( 0 , APP_TX_DUTYCYCLE_RND ); LoRaWAN . cycle ( txDutyCycleTime ); deviceState = DEVICE_STATE_SLEEP ; #endif break ; } case DEVICE_STATE_SLEEP : { LoRaWAN . sleep (); break ; } default : { deviceState = DEVICE_STATE_INIT ; break ; } } }","title":"main.cpp"},{"location":"software/node/main.cpp/#maincpp","text":"This section describes the modular node which allows to collect and send environmental metrics to a backend. While it is possible to use pure LoRa to communicate with a backend, the code provided here uses only LoRaWAN . While a specific hardware was used to build the nodes, it is possible to replace the transmission logic with other libraries. All code described here is found in node/src/main.cpp . Below is a highlighted version of the code fragment 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 #include \"Arduino.h\" . #include \"LoRaWan_APP.h\" #include \"config.h\" #include <CayenneLPP.h> #include <DallasTemperature.h> #include <OneWire.h> #include <SPI.h> #include <Wire.h> #include <softSerial.h> #include \"MB7389.h\" #include \"VH400.h\" // This section allows to store data on the device. Specifically this allows to // store the rain gauge *mm per tip* value. #define ROW 0 #define ROW_OFFSET 100 // CY_FLASH_SIZEOF_ROW is 256 , CY_SFLASH_USERBASE is 0x0ffff400 #define addr_rain_gauge \\ CY_SFLASH_USERBASE + CY_FLASH_SIZEOF_ROW *ROW + ROW_OFFSET CayenneLPP lpp ( LORAWAN_APP_DATA_MAX_SIZE ); // Set to BATTERY_SEND_INTERVAL to send on start uint32_t battery_send_counter = BATTERY_SEND_INTERVAL ; // Run cycle every minute uint32_t appTxDutyCycle = 60000 ; // Send messages on specific port. For this application all data is transmitted // on port 2. The port is used to distinguish between packet types, however // since this implementation uses CayenneLPP which is parsed by the backend, all // data can be sent over the same port. uint8_t appPort = 2 ; // Initialize variables required for rain gauge use #ifdef RAIN_GAUGE_PIN // union to store directly on EEPROM union { float number ; uint8_t bytes [ 4 ]; } mm_per_tip ; // The tip counter and mm, must reset after each cycle static volatile uint8_t tips = 0 ; static unsigned long last_switch ; #endif // Initialize variables required for OneWire temperature // // The current setup only supports a single connected sensor while it is easily // possible to monitor multiple OneWire sensors at the same time. #ifdef ONEWIRE_PIN OneWire onewire ( ONEWIRE_PIN ); DallasTemperature onewire_sensor ( & onewire ); uint32_t onewire_send_counter = 0 ; float onewire_total = 0.0 ; #endif // Initialize variables required for VH400 moisture sensor #ifdef VH400_PIN uint32_t vh400_send_counter = 0 ; float vh400_total = 0.0 ; #endif // Initialize variables for MB7389 ultrasonic distance sensor #ifdef SONIC_RX_PIN uint32_t sonic_send_counter = 0 ; uint32_t sonic_total = 0 ; softSerial sonicSerial ( 0 , SONIC_RX_PIN ); #endif // Prepare the outgoing packet stored in CayenneLPP format // // The packet might be empty and sending is omitted for that cycle. static void prepareTxFrame () { lpp . reset (); // Send battery status only every \"BATTERY_SEND_INTERVAL\" minutes if ( battery_send_counter >= BATTERY_SEND_INTERVAL ) { Serial . printf ( \"[%i/%i] Add battery volt \\n \" , battery_send_counter , BATTERY_SEND_INTERVAL ); // Battery voltage is stored as voltage with ID 1 lpp . addVoltage ( 1 , getBatteryVoltage () / 1000.0 ); // Running version is stored as digital output with ID 1 lpp . addDigitalOutput ( 1 , VERSION ); // Reset counter battery_send_counter = 0 ; } else { Serial . printf ( \"[%i/%i] Skip battery volt \\n \" , battery_send_counter , BATTERY_SEND_INTERVAL ); battery_send_counter ++ ; } #ifdef SONIC_RX_PIN sonic_total += get_sonic_distance ( sonicSerial , 60 ); sonic_send_counter ++ ; if ( sonic_send_counter == SONIC_SEND_INTERVAL ) { Serial . printf ( \"[%i/%i] Add sonic \\n \" , sonic_send_counter , SONIC_SEND_INTERVAL ); // Sea level is stored as distance with ID 1 lpp . addDistance ( 1 , (( float ) sonic_total / sonic_send_counter ) / 100.0 ); // Reset counters sonic_send_counter = 0 ; sonic_total = 0 ; } else { Serial . printf ( \"[%i/%i] Skip sonic \\n \" , sonic_send_counter , SONIC_SEND_INTERVAL ); } #endif #ifdef RAIN_GAUGE_PIN if ( tips > 0 ) { Serial . printf ( \"Tips = %i \\n \" , tips ); // Rain fall is stored as analog with ID 1 // The CayenneLPP specification do not support rain fall directly lpp . addAnalogInput ( 1 , mm_per_tip . number * tips ); // Reset counter tips = 0 ; } else { Serial . printf ( \"Skip rain gauge \\n \" ); } #endif #ifdef VH400_PIN vh400_total += read_VH400 ( VH400_PIN ); vh400_send_counter ++ ; if ( vh400_send_counter >= VH400_SEND_INTERVAL ) { Serial . printf ( \"[%i/%i] Add VH400 \\n \" , vh400_send_counter , VH400_SEND_INTERVAL ); // Moisture is stored as analog with ID 2 // The CayenneLPP specification do not support moisture directly lpp . addAnalogInput ( 2 , vh400_total / vh400_send_counter ); // Reset counters vh400_send_counter = 0 ; vh400_total = 0.0 ; } else { Serial . printf ( \"[%i/%i] Skip VH400 \\n \" , vh400_send_counter , VH400_SEND_INTERVAL ); } #endif #ifdef ONEWIRE_PIN onewire_sensor . requestTemperatures (); onewire_total += onewire_sensor . getTempCByIndex ( 0 ); onewire_send_counter ++ ; if ( onewire_send_counter >= ONEWIRE_SEND_INTERVAL ) { Serial . printf ( \"[%i/%i] Add OneWire \\n \" , onewire_send_counter , ONEWIRE_SEND_INTERVAL ); // Temperature is stored as temperature with ID 1 lpp . addTemperature ( 1 , onewire_total / onewire_send_counter ); // Reset counters onewire_send_counter = 0 ; onewire_total = 0.0 ; } else { Serial . printf ( \"[%i/%i] Skip OneWire \\n \" , onewire_send_counter , ONEWIRE_SEND_INTERVAL ); } #endif // Copy CayenneLPP frame to appData, which will be send lpp . getBuffer (), appDataSize = lpp . getSize (); memcpy ( appData , lpp . getBuffer (), appDataSize ); } // Custom commands to provision device // // At this point only the rain gauge command `mmPerTip` is supported, however it // is easily possible to extend this to e.g. support height setting of the tide // gauges or other user specific commands. bool checkUserAt ( char * cmd , char * content ) { #ifdef RAIN_GAUGE_PIN // This command is used to set the tipping bucket size // - HOBO RG3: 0.254mm/t // - Misol WH-SP-RG: 0.3851mm/t if ( strcmp ( cmd , \"mmPerTip\" ) == 0 ) { if ( atof ( content ) != mm_per_tip . number ) { mm_per_tip . number = atof ( content ); Serial . print ( \"+OK Set mm per tip to \" ); Serial . print ( mm_per_tip . number , 4 ); Serial . println ( \"mm\" ); Serial . println (); FLASH_update ( addr_rain_gauge , mm_per_tip . bytes , sizeof ( mm_per_tip . bytes )); } else { Serial . println ( \"+OK Same mm per tip as before\" ); } return true ; } #endif return false ; } #ifdef RAIN_GAUGE_PIN // Run on each interrupt aka tip of the tipping bucket void interrupt_handler () { tips ++ ; delay ( 250 ); } #endif // The Arduino setup() function run on every boot void setup () { // Set baudrate to 115200 Serial . begin ( 115200 ); Serial . println ( \"So it begins...\" ); #ifdef RAIN_GAUGE_PIN // Read mm/t from EEPROM Serial . println ( \"Enable rain gauge sensor\" ); FLASH_read_at ( addr_rain_gauge , mm_per_tip . bytes , sizeof ( mm_per_tip . bytes )); if ( mm_per_tip . number == 0.0 ) { mm_per_tip . number = DEFAULT_MM_PER_COUNT ; } Serial . printf ( \"Current mm per tip is \" ); Serial . print ( mm_per_tip . number , 4 ); Serial . println ( \"mm\" ); // Enable interrupt pin for tips PINMODE_INPUT_PULLUP ( RAIN_GAUGE_PIN ); attachInterrupt ( RAIN_GAUGE_PIN , interrupt_handler , FALLING ); #endif #ifdef ONEWIRE_PIN // Setup OneWire and print single test measurement Serial . println ( \"Enable OneWire sensor\" ); onewire_sensor . begin (); onewire_sensor . requestTemperatures (); Serial . print ( \"temperature = \" ); Serial . print ( onewire_sensor . getTempCByIndex ( 0 ), 2 ); Serial . println (); #endif // Enable user input via Serial for AT commands enableAt (); #ifdef VH400_PIN // Setup VH400 sensor and print single test measurement Serial . println ( \"Enable VH400 sensor\" ); pinMode ( VH400_PIN , INPUT ); Serial . print ( \"moisture = \" ); Serial . print ( readVH400 ( VH400_PIN ), 2 ) Serial . println (); #endif #ifdef SONIC_RX_PIN // Print single test measurement Serial . println ( \"Enable sonic sensor\" ); Serial . print ( \"distance = \" ); Serial . print ( get_sonic_distance ( sonicSerial , 1 )); Serial . println (); #endif // Set Arduino into the initialization state deviceState = DEVICE_STATE_INIT ; LoRaWAN . ifskipjoin (); } void loop () { switch ( deviceState ) { case DEVICE_STATE_INIT : { getDevParam (); printDevParam (); LoRaWAN . init ( loraWanClass , loraWanRegion ); deviceState = DEVICE_STATE_JOIN ; break ; } case DEVICE_STATE_JOIN : { LoRaWAN . join (); break ; } case DEVICE_STATE_SEND : { prepareTxFrame (); // Do not send empty packages if ( appDataSize > 0 ) { LoRaWAN . send (); } else { Serial . println ( \"Package is empty, don't send anything\" ); } deviceState = DEVICE_STATE_CYCLE ; break ; } case DEVICE_STATE_CYCLE : { // If sonic sensor is enabled it will measure 60 times a minute and return the // average. This way waves don't influence tide estimations as much. Since a // measurement is required every second the duty cycle is skipped and instead // the get_sonic_distance function runs, which blocks for 60 seconds. // If no sonic sensor is attached, use the #ifdef SONIC_RX_PIN LoRaWAN . sleep (); // Add random delay so sensors don't repetitively send at the same time. // This is done do avoid a situation where many sensors start at the same // time and collectively overload the gateway every 60 seconds. delay ( randr ( 0 , APP_TX_DUTYCYCLE_RND )); deviceState = DEVICE_STATE_SEND ; #else // Same random delay is applied here. txDutyCycleTime = appTxDutyCycle + randr ( 0 , APP_TX_DUTYCYCLE_RND ); LoRaWAN . cycle ( txDutyCycleTime ); deviceState = DEVICE_STATE_SLEEP ; #endif break ; } case DEVICE_STATE_SLEEP : { LoRaWAN . sleep (); break ; } default : { deviceState = DEVICE_STATE_INIT ; break ; } } }","title":"main.cpp"}]}